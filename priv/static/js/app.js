/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();\n\n//# sourceURL=webpack:///../deps/phoenix_html/priv/static/phoenix_html.js?");

/***/ }),

/***/ "./css/app.css":
/*!*********************!*\
  !*** ./css/app.css ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./css/app.css?");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.css */ \"./css/app.css\");\n/* harmony import */ var _css_app_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_css__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game */ \"./js/game.js\");\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import dependencies\n//\n\n // Import local files\n//\n// Local files can be imported directly using relative paths, for example:\n// import socket from \"./socket\"\n\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  var game = new _game__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n  window.game = game; //For debugging only\n});\n\n//# sourceURL=webpack:///./js/app.js?");

/***/ }),

/***/ "./js/game.js":
/*!********************!*\
  !*** ./js/game.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _preloader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./preloader */ \"./js/preloader.js\");\n/* harmony import */ var _vendor_FBXLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vendor/FBXLoader */ \"./js/vendor/FBXLoader.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ \"./js/geometry.js\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar Game = /*#__PURE__*/function () {\n  // preload game assets\n  function Game() {\n    _classCallCheck(this, Game);\n\n    var game = this;\n    this.player = {};\n    this.modes = Object.freeze({\n      NONE: Symbol(\"none\"),\n      INIT: Symbol(\"init\"),\n      ACTIVE: Symbol(\"active\")\n    });\n    this.mode = this.modes.NONE;\n    var options = {\n      assets: [],\n      oncomplete: function oncomplete() {\n        game.init();\n        game.animate();\n      }\n    }; // first animation is set as soon as the character is spawned\n\n    this.animations = [\"standing\", \"walking\", \"dancing\", \"sitting\", \"sit-look-around\"];\n    this.assetsPath = 'fbx/';\n    this.animations.forEach(function (animation) {\n      options.assets.push(\"\".concat(game.assetsPath).concat(animation, \".fbx\"));\n    });\n    this.clock = new THREE.Clock();\n    var preloader = new _preloader__WEBPACK_IMPORTED_MODULE_0__[\"default\"](options);\n\n    window.onError = function (error) {\n      console.error(JSON.stringify(error));\n    };\n  } // initialises the game scene, camera and objects\n\n\n  _createClass(Game, [{\n    key: \"init\",\n    value: function init() {\n      var _this = this;\n\n      this.mode = this.modes.INIT; // scene setup, light camera and background.\n\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0x2edaff); // grid helper\n\n      var size = 1000;\n      var divisions = 10;\n      var gridHelper = new THREE.GridHelper(size, divisions); //this.scene.add( gridHelper );\n\n      var light = new THREE.HemisphereLight(0xffffff, 0x444444, 1);\n      light.position.set(0, 500, 0);\n      this.scene.add(light);\n      light = new THREE.DirectionalLight(0xffffff, 0.1);\n      light.position.set(0, 200, 100);\n      light.castShadow = true;\n      light.shadow.mapSize.width = 2048;\n      light.shadow.mapSize.height = 2048;\n      light.shadow.camera.top = 3000;\n      light.shadow.camera.bottom = -3000;\n      light.shadow.camera.left = -3000;\n      light.shadow.camera.right = 3000;\n      light.shadow.camera.far = 3000;\n      this.scene.add(light); // ground\n\n      /*\n            var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry    ( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999,     depthWrite: false } ) );\n            mesh.rotation.x = - Math.PI / 2;\n            //mesh.position.y = -100;\n            mesh.receiveShadow = true;\n            this.scene.add( mesh );\n      */\n\n      var light_2 = new THREE.PointLight(0x000000, 1, 100);\n      light_2.position.set(50, 50, 50);\n      this.scene.add(light_2);\n      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);\n      this.camera.position.set(112, 100, 200);\n      this.camera.quaternion.set(0.07133122876303646, -0.17495722675648318, -0.006135162916936811, -0.9819695435118246);\n      this.renderer = new THREE.WebGLRenderer();\n      this.renderer.setSize(window.innerWidth, window.innerHeight);\n      document.getElementById(\"renderer\").appendChild(this.renderer.domElement); // model setup\n\n      var loader = new THREE.FBXLoader();\n      var game = this; // bootup model with the first animation\n\n      loader.load(\"\".concat(this.assetsPath).concat(this.animations[0], \".fbx\"), function (object) {\n        object.mixer = new THREE.AnimationMixer(object);\n        game.player.mixer = object.mixer;\n        game.player.root = object.mixer.getRoot();\n        var first_action = game.player.mixer.clipAction(object.animations[0]);\n        first_action.play();\n        object.name = \"Character\";\n        game.player.object = object;\n        object.traverse(function (child) {\n          if (child.isMesh) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n          }\n        });\n        game.scene.add(object);\n        game.mode = game.modes.ACTIVE;\n      }); // load remaining animations\n\n      this.animations.forEach(function (animation) {\n        loader.load(\"\".concat(game.assetsPath).concat(animation, \".fbx\"), function (object) {\n          game.player[animation] = object.animations[0];\n        });\n      }); //setup keybindings\n\n      game.player.move = {\n        forward: 0,\n        direction: 0\n      };\n      document.addEventListener(\"keydown\", function (event) {\n        console.log(event);\n        console.log(game.player.object.rotation);\n        console.log(game.player.object.position);\n        console.log(game.player.object.quaternion);\n\n        if (event.code === \"KeyW\") {\n          game.player.move.forward = 1;\n          game.action = 'walking';\n        } // Space either plays interaction or 'dancing' by default\n\n\n        if (event.code === \"Space\") {\n          _this.playing_interaction = false;\n\n          for (var interaction_name in _this.interactions) {\n            var interaction = _this.interactions[interaction_name];\n\n            if (interaction[\"triggered\"]) {\n              interaction.interact(interaction[\"object\"]);\n              _this.playing_interaction = true;\n              interaction[\"triggered\"] = false;\n            }\n          }\n\n          if (!_this.playing_interaction) {\n            game.action = 'dancing';\n          }\n        }\n\n        if (event.code === \"KeyA\") game.player.move.direction = 3;\n        if (event.code === \"KeyD\") game.player.move.direction = -3;\n      });\n      document.addEventListener(\"keyup\", function (event) {\n        if (event.code === \"KeyW\") {\n          game.player.move.forward = 0;\n          game.action = 'standing';\n        }\n\n        if (event.code === \"KeyA\") game.player.move.direction = 0;\n        if (event.code === \"KeyD\") game.player.move.direction = 0;\n      }); // environment\n\n      game.loadEnvironment(loader);\n    }\n  }, {\n    key: \"loadInteractions\",\n    value: function loadInteractions() {\n      this.interactions = {\n        'OfficeChair_02': {\n          interact: game.interaction_sitOnChair,\n          \"object\": null,\n          \"distance\": 100,\n          \"triggered\": false,\n          \"action\": \"sitting\"\n        }\n      };\n      game = this;\n\n      for (var interaction_name in this.interactions) {\n        game.environmentProxy.children.forEach(function (mesh) {\n          if (mesh.name === interaction_name) {\n            game.interactions[interaction_name][\"object\"] = mesh;\n          }\n        });\n      }\n    }\n  }, {\n    key: \"interaction_sitOnChair\",\n    value: function interaction_sitOnChair(mesh) {\n      // follows example of hardcoded value for the chair of\n      // the current environment\n      game.player.object.position.x = -1 * mesh.position.x + 60;\n      game.player.object.position.y = mesh.position.y;\n      game.player.object.position.z = -1 * mesh.position.z;\n      game.player.object.rotation.y = -4.8;\n      game.action = \"sitting\";\n      game.player.mixer.addEventListener('finished', function () {\n        game.player.object.position.x -= 25;\n        game.action = \"sit-look-around\";\n      });\n    }\n  }, {\n    key: \"loadEnvironment\",\n    value: function loadEnvironment(loader) {\n      var game = this;\n      loader.load(\"\".concat(this.assetsPath, \"game_environment.fbx\"), function (object) {\n        game.scene.add(object);\n        object.receiveShadow = true;\n        object.name = \"Environment\"; //object.scale.set(0.6, 0.6, 0.6);\n\n        object.rotateY(Math.PI);\n        object.position.y = -20;\n        object.traverse(function (child) {\n          if (child.isMesh) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n          }\n        });\n        game.environmentProxy = object;\n        game.loadInteractions();\n      });\n    }\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      var game = this;\n      var dt = this.clock.getDelta();\n      requestAnimationFrame(function () {\n        game.animate();\n      }); // animation mixer\n\n      if (this.player.mixer != undefined && this.mode == this.modes.ACTIVE) {\n        this.player.mixer.update(dt);\n      } // movements\n\n\n      if (this.player.object != undefined) {\n        // player object translations\n        if (this.player.move.forward > 0) this.moveForward(dt);\n        this.player.object.rotation.y += this.player.move.direction * dt; // camera tracking\n\n        var player_position = this.player.object.position.clone();\n        var camera_position = this.player.object.position.clone();\n        var camera_distance = 500;\n        var camera_angle = Math.PI / 4 + this.player.object.rotation.x;\n        camera_position.y += Math.sin(camera_angle) * (camera_distance - 150);\n        camera_position.z -= Math.cos(camera_angle) * camera_distance;\n        this.camera.position.set(camera_position.x, camera_position.y, camera_position.z);\n        this.camera.lookAt(player_position);\n      } // interactions\n\n\n      if (this.interactions != undefined && this.player.object != undefined) {\n        for (var interaction_name in this.interactions) {\n          var interaction = this.interactions[interaction_name]; // for some unknown reason we need to adjust position of the mesh\n\n          var object_adjusted_position = interaction[\"object\"].position.clone();\n          object_adjusted_position.z *= -1;\n          object_adjusted_position.x *= -1;\n          var curr_distance = this.player.object.position.distanceTo(object_adjusted_position);\n          console.log(curr_distance);\n\n          if (curr_distance <= interaction[\"distance\"]) {\n            interaction[\"triggered\"] = true;\n            document.getElementById(\"message\").style.display = \"block\";\n          } else {\n            document.getElementById(\"message\").style.display = \"none\";\n            interaction[\"triggered\"] = false;\n          }\n        }\n      }\n\n      this.renderer.render(this.scene, this.camera);\n    }\n  }, {\n    key: \"moveForward\",\n    value: function moveForward(dt) {\n      /* raycasting (object collision) */\n      var player_position = this.player.object.position.clone();\n      var dir = this.player.object.getWorldDirection();\n      var raycaster_foot = new THREE.Raycaster(player_position, dir);\n      player_position.y += 1;\n      var raycaster_head = new THREE.Raycaster(player_position, dir);\n      var blocked = false;\n\n      var _iterator = _createForOfIteratorHelper(this.environmentProxy.children),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var box = _step.value;\n          var intersect_foot = raycaster_foot.intersectObject(box);\n          var intersect_head = raycaster_foot.intersectObject(box);\n\n          if (intersect_foot.length > 0 && intersect_foot[0].distance < 50) {\n            blocked = true;\n            break;\n          }\n\n          if (intersect_head.length > 0 && intersect_head[0].distance < 50) {\n            blocked = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (blocked) return;\n      /* move on the surface of the cylinder */\n\n      var rotation = Math.cos(this.player.object.rotation.y);\n      var translation = Math.sin(this.player.object.rotation.y);\n      console.log(rotation, translation);\n      Object(_geometry__WEBPACK_IMPORTED_MODULE_2__[\"rotateAboutCenter\"])(this.player.object, new THREE.Vector3(this.player.object.position.x, -2000, 0), THREE.Math.degToRad(5 * dt * rotation));\n      this.player.object.position.x += dt * 150 * translation;\n    }\n  }, {\n    key: \"action\",\n    set: function set(name) {\n      var animation = this.player[name];\n      var action = this.player.mixer.clipAction(animation);\n      action.time = 0;\n      this.player.mixer.stopAllAction();\n      this.player.action = name; //action.fadeIn(0.1);\n\n      if (name == 'sitting') action.loop = THREE.LoopOnce; //if (name==\"sit-look-around\") action.fadeIn(0.5)\n\n      action.play();\n    }\n  }]);\n\n  return Game;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);\n\n//# sourceURL=webpack:///./js/game.js?");

/***/ }),

/***/ "./js/geometry.js":
/*!************************!*\
  !*** ./js/geometry.js ***!
  \************************/
/*! exports provided: rotateAboutCenter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateAboutCenter\", function() { return rotateAboutCenter; });\n// obj - your object (THREE.Object3D or derived)\n// point - the point of rotation (THREE.Vector3)\n// axis - the axis of rotation (normalized THREE.Vector3)\n// theta - radian value of rotation\n// pointIsWorld - boolean indicating the point is in world coordinates (default = false)\nfunction rotateAboutCenter(obj, point, theta, pointIsWorld) {\n  pointIsWorld = pointIsWorld === undefined ? false : pointIsWorld;\n\n  if (pointIsWorld) {\n    obj.parent.localToWorld(obj.position); // compensate for world coordinate\n  }\n\n  obj.position.sub(point); // remove the offset\n\n  var axis = new THREE.Vector3(1, 0, 0);\n  obj.position.applyAxisAngle(axis, theta); // rotate the POSITION\n\n  obj.position.add(point); // re-add the offset\n\n  if (pointIsWorld) {\n    obj.parent.worldToLocal(obj.position); // undo world coordinates compensation\n  }\n\n  obj.rotation.x += theta; // rotate the OBJECT\n}\n\n\n\n//# sourceURL=webpack:///./js/geometry.js?");

/***/ }),

/***/ "./js/preloader.js":
/*!*************************!*\
  !*** ./js/preloader.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Preloader = /*#__PURE__*/function () {\n  // prepare load bar for assets loading, you can pass\n  // options.container to append it there as a children\n  function Preloader(options) {\n    _classCallCheck(this, Preloader);\n\n    this.assets = {};\n\n    var _iterator = _createForOfIteratorHelper(options.assets),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var asset = _step.value;\n        this.assets[asset] = {\n          loaded: 0,\n          complete: false\n        };\n        this.load(asset);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this.container = options.container;\n\n    if (options.onprogress == undefined) {\n      this.onprogress = onprogress;\n      this.domElement = document.createElement(\"div\");\n      this.domElement.style.position = 'absolute';\n      this.domElement.style.top = '0';\n      this.domElement.style.left = '0';\n      this.domElement.style.width = '100%';\n      this.domElement.style.height = '100%';\n      this.domElement.style.background = '#000';\n      this.domElement.style.opacity = '0.7';\n      this.domElement.style.display = 'flex';\n      this.domElement.style.alignItems = 'center';\n      this.domElement.style.justifyContent = 'center';\n      this.domElement.style.zIndex = '1111';\n      var barBase = document.createElement(\"div\");\n      barBase.style.background = '#aaa';\n      barBase.style.width = '50%';\n      barBase.style.minWidth = '250px';\n      barBase.style.borderRadius = '10px';\n      barBase.style.height = '15px';\n      this.domElement.appendChild(barBase);\n      var bar = document.createElement(\"div\");\n      bar.style.background = 'blue';\n      bar.style.width = '50%';\n      bar.style.borderRadius = '10px';\n      bar.style.height = '100%';\n      bar.style.width = '0';\n      barBase.appendChild(bar);\n      this.progressBar = bar;\n\n      if (this.container != undefined) {\n        this.container.appendChild(this.domElement);\n      } else {\n        document.body.appendChild(this.domElement);\n      }\n    } else {\n      this.onprogress = options.onprogress;\n    }\n\n    this.oncomplete = options.oncomplete;\n    var loader = this;\n\n    function onprogress(delta) {\n      var progress = delta * 100;\n      loader.progressBar.style.width = \"\".concat(progress, \"%\");\n    }\n  }\n\n  _createClass(Preloader, [{\n    key: \"checkCompleted\",\n    value: function checkCompleted() {\n      for (var prop in this.assets) {\n        var asset = this.assets[prop];\n        if (!asset.complete) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      var loader = this;\n      var xobj = new XMLHttpRequest();\n      xobj.overrideMimeType(\"application/json\");\n      xobj.open('GET', url, true);\n\n      xobj.onreadystatechange = function () {\n        if (xobj.readyState == 4 && xobj.status == \"200\") {\n          loader.assets[url].complete = true;\n\n          if (loader.checkCompleted()) {\n            if (loader.domElement != undefined) {\n              if (loader.container != undefined) {\n                loader.container.removeChild(loader.domElement);\n              } else {\n                document.body.removeChild(loader.domElement);\n              }\n            }\n\n            loader.oncomplete();\n          }\n        }\n      };\n\n      xobj.onprogress = function (e) {\n        var asset = loader.assets[url];\n        asset.loaded = e.loaded;\n        asset.total = e.total;\n        loader.onprogress(loader.progress);\n      };\n\n      xobj.send(null);\n    }\n  }, {\n    key: \"progress\",\n    get: function get() {\n      var total = 0;\n      var loaded = 0;\n\n      for (var prop in this.assets) {\n        var asset = this.assets[prop];\n\n        if (asset.total == undefined) {\n          loaded = 0;\n          break;\n        }\n\n        loaded += asset.loaded;\n        total += asset.total;\n      }\n\n      return loaded / total;\n    }\n  }]);\n\n  return Preloader;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Preloader);\n\n//# sourceURL=webpack:///./js/preloader.js?");

/***/ }),

/***/ "./js/vendor/FBXLoader.js":
/*!********************************!*\
  !*** ./js/vendor/FBXLoader.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _inflate_module_min_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inflate.module.min.js */ \"./js/vendor/inflate.module.min.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\n\n(function () {\n  THREE.FBXLoader = function (manager) {\n    this.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n  };\n\n  Object.assign(THREE.FBXLoader.prototype, {\n    load: function load(url, onLoad, onProgress, onError) {\n      var self = this;\n      var resourceDirectory = THREE.LoaderUtils.extractUrlBase(url);\n      var loader = new THREE.FileLoader(this.manager);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        try {\n          var scene = self.parse(buffer, resourceDirectory);\n          onLoad(scene);\n        } catch (error) {\n          window.setTimeout(function () {\n            if (onError) onError(error);\n            self.manager.itemError(url);\n          }, 0);\n        }\n      }, onProgress, onError);\n    },\n    parse: function parse(FBXBuffer, resourceDirectory) {\n      var FBXTree;\n\n      if (isFbxFormatBinary(FBXBuffer)) {\n        FBXTree = new BinaryParser().parse(FBXBuffer);\n      } else {\n        var FBXText = convertArrayBufferToString(FBXBuffer);\n\n        if (!isFbxFormatASCII(FBXText)) {\n          throw new Error('THREE.FBXLoader: Unknown format.');\n        }\n\n        if (getFbxVersion(FBXText) < 7000) {\n          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n        }\n\n        FBXTree = new TextParser().parse(FBXText);\n      } // console.log( FBXTree );\n\n\n      var connections = parseConnections(FBXTree);\n      var images = parseImages(FBXTree);\n      var textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n      var materials = parseMaterials(FBXTree, textures, connections);\n      var deformers = parseDeformers(FBXTree, connections);\n      var geometryMap = parseGeometries(FBXTree, connections, deformers);\n      var sceneGraph = parseScene(FBXTree, connections, deformers.skeletons, geometryMap, materials);\n      return sceneGraph;\n    }\n  }); // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n  // and details the connection type\n\n  function parseConnections(FBXTree) {\n    var connectionMap = new Map();\n\n    if ('Connections' in FBXTree) {\n      var rawConnections = FBXTree.Connections.connections;\n      rawConnections.forEach(function (rawConnection) {\n        var fromID = rawConnection[0];\n        var toID = rawConnection[1];\n        var relationship = rawConnection[2];\n\n        if (!connectionMap.has(fromID)) {\n          connectionMap.set(fromID, {\n            parents: [],\n            children: []\n          });\n        }\n\n        var parentRelationship = {\n          ID: toID,\n          relationship: relationship\n        };\n        connectionMap.get(fromID).parents.push(parentRelationship);\n\n        if (!connectionMap.has(toID)) {\n          connectionMap.set(toID, {\n            parents: [],\n            children: []\n          });\n        }\n\n        var childRelationship = {\n          ID: fromID,\n          relationship: relationship\n        };\n        connectionMap.get(toID).children.push(childRelationship);\n      });\n    }\n\n    return connectionMap;\n  } // Parse FBXTree.Objects.Video for embedded image data\n  // These images are connected to textures in FBXTree.Objects.Textures\n  // via FBXTree.Connections.\n\n\n  function parseImages(FBXTree) {\n    var images = {};\n    var blobs = {};\n\n    if ('Video' in FBXTree.Objects) {\n      var videoNodes = FBXTree.Objects.Video;\n\n      for (var nodeID in videoNodes) {\n        var videoNode = videoNodes[nodeID];\n        var id = parseInt(nodeID);\n        images[id] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content\n\n        if ('Content' in videoNode) {\n          var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n          var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n\n          if (arrayBufferContent || base64Content) {\n            var image = parseImage(videoNodes[nodeID]);\n            blobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n          }\n        }\n      }\n    }\n\n    for (var id in images) {\n      var filename = images[id];\n      if (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\n    }\n\n    return images;\n  } // Parse embedded image data in FBXTree.Video.Content\n\n\n  function parseImage(videoNode) {\n    var content = videoNode.Content;\n    var fileName = videoNode.RelativeFilename || videoNode.Filename;\n    var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n    var type;\n\n    switch (extension) {\n      case 'bmp':\n        type = 'image/bmp';\n        break;\n\n      case 'jpg':\n      case 'jpeg':\n        type = 'image/jpeg';\n        break;\n\n      case 'png':\n        type = 'image/png';\n        break;\n\n      case 'tif':\n        type = 'image/tiff';\n        break;\n\n      case 'tga':\n        if (typeof THREE.TGALoader !== 'function') {\n          console.warn('FBXLoader: THREE.TGALoader is required to load TGA textures');\n          return;\n        } else {\n          if (THREE.Loader.Handlers.get('.tga') === null) {\n            THREE.Loader.Handlers.add(/\\.tga$/i, new THREE.TGALoader());\n          }\n\n          type = 'image/tga';\n          break;\n        }\n\n      default:\n        console.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n        return;\n    }\n\n    if (typeof content === 'string') {\n      // ASCII format\n      return 'data:' + type + ';base64,' + content;\n    } else {\n      // Binary Format\n      var array = new Uint8Array(content);\n      return window.URL.createObjectURL(new Blob([array], {\n        type: type\n      }));\n    }\n  } // Parse nodes in FBXTree.Objects.Texture\n  // These contain details such as UV scaling, cropping, rotation etc and are connected\n  // to images in FBXTree.Objects.Video\n\n\n  function parseTextures(FBXTree, loader, images, connections) {\n    var textureMap = new Map();\n\n    if ('Texture' in FBXTree.Objects) {\n      var textureNodes = FBXTree.Objects.Texture;\n\n      for (var nodeID in textureNodes) {\n        var texture = parseTexture(textureNodes[nodeID], loader, images, connections);\n        textureMap.set(parseInt(nodeID), texture);\n      }\n    }\n\n    return textureMap;\n  } // Parse individual node in FBXTree.Objects.Texture\n\n\n  function parseTexture(textureNode, loader, images, connections) {\n    var texture = loadTexture(textureNode, loader, images, connections);\n    texture.ID = textureNode.id;\n    texture.name = textureNode.attrName;\n    var wrapModeU = textureNode.WrapModeU;\n    var wrapModeV = textureNode.WrapModeV;\n    var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n    var valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n    // 0: repeat(default), 1: clamp\n\n    texture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n    texture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n    if ('Scaling' in textureNode) {\n      var values = textureNode.Scaling.value;\n      texture.repeat.x = values[0];\n      texture.repeat.y = values[1];\n    }\n\n    return texture;\n  } // load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\n\n  function loadTexture(textureNode, loader, images, connections) {\n    var fileName;\n    var currentPath = loader.path;\n    var children = connections.get(textureNode.id).children;\n\n    if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n      fileName = images[children[0].ID];\n\n      if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n        loader.setPath(undefined);\n      }\n    }\n\n    var texture;\n\n    if (textureNode.FileName.slice(-3).toLowerCase() === 'tga') {\n      texture = THREE.Loader.Handlers.get('.tga').load(fileName);\n    } else {\n      texture = loader.load(fileName);\n    }\n\n    loader.setPath(currentPath);\n    return texture;\n  } // Parse nodes in FBXTree.Objects.Material\n\n\n  function parseMaterials(FBXTree, textureMap, connections) {\n    var materialMap = new Map();\n\n    if ('Material' in FBXTree.Objects) {\n      var materialNodes = FBXTree.Objects.Material;\n\n      for (var nodeID in materialNodes) {\n        var material = parseMaterial(FBXTree, materialNodes[nodeID], textureMap, connections);\n        if (material !== null) materialMap.set(parseInt(nodeID), material);\n      }\n    }\n\n    return materialMap;\n  } // Parse single node in FBXTree.Objects.Material\n  // Materials are connected to texture maps in FBXTree.Objects.Textures\n  // FBX format currently only supports Lambert and Phong shading models\n\n\n  function parseMaterial(FBXTree, materialNode, textureMap, connections) {\n    var ID = materialNode.id;\n    var name = materialNode.attrName;\n    var type = materialNode.ShadingModel; //Case where FBX wraps shading model in property object.\n\n    if (_typeof(type) === 'object') {\n      type = type.value;\n    } // Ignore unused materials which don't have any connections.\n\n\n    if (!connections.has(ID)) return null;\n    var parameters = parseParameters(FBXTree, materialNode, textureMap, ID, connections);\n    var material;\n\n    switch (type.toLowerCase()) {\n      case 'phong':\n        material = new THREE.MeshPhongMaterial();\n        break;\n\n      case 'lambert':\n        material = new THREE.MeshLambertMaterial();\n        break;\n\n      default:\n        console.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n        material = new THREE.MeshPhongMaterial({\n          color: 0x3300ff\n        });\n        break;\n    }\n\n    material.setValues(parameters);\n    material.name = name;\n    return material;\n  } // Parse FBX material and return parameters suitable for a three.js material\n  // Also parse the texture map and return any textures associated with the material\n\n\n  function parseParameters(FBXTree, properties, textureMap, ID, connections) {\n    var parameters = {};\n\n    if (properties.BumpFactor) {\n      parameters.bumpScale = properties.BumpFactor.value;\n    }\n\n    if (properties.Diffuse) {\n      parameters.color = new THREE.Color().fromArray(properties.Diffuse.value);\n    } else if (properties.DiffuseColor && properties.DiffuseColor.type === 'Color') {\n      // The blender exporter exports diffuse here instead of in properties.Diffuse\n      parameters.color = new THREE.Color().fromArray(properties.DiffuseColor.value);\n    }\n\n    if (properties.DisplacementFactor) {\n      parameters.displacementScale = properties.DisplacementFactor.value;\n    }\n\n    if (properties.Emissive) {\n      parameters.emissive = new THREE.Color().fromArray(properties.Emissive.value);\n    } else if (properties.EmissiveColor && properties.EmissiveColor.type === 'Color') {\n      // The blender exporter exports emissive color here instead of in properties.Emissive\n      parameters.emissive = new THREE.Color().fromArray(properties.EmissiveColor.value);\n    }\n\n    if (properties.EmissiveFactor) {\n      parameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);\n    }\n\n    if (properties.Opacity) {\n      parameters.opacity = parseFloat(properties.Opacity.value);\n    }\n\n    if (parameters.opacity < 1.0) {\n      parameters.transparent = true;\n    }\n\n    if (properties.ReflectionFactor) {\n      parameters.reflectivity = properties.ReflectionFactor.value;\n    }\n\n    if (properties.Shininess) {\n      parameters.shininess = properties.Shininess.value;\n    }\n\n    if (properties.Specular) {\n      parameters.specular = new THREE.Color().fromArray(properties.Specular.value);\n    } else if (properties.SpecularColor && properties.SpecularColor.type === 'Color') {\n      // The blender exporter exports specular color here instead of in properties.Specular\n      parameters.specular = new THREE.Color().fromArray(properties.SpecularColor.value);\n    }\n\n    connections.get(ID).children.forEach(function (child) {\n      var type = child.relationship;\n\n      switch (type) {\n        case 'Bump':\n          parameters.bumpMap = textureMap.get(child.ID);\n          break;\n\n        case 'DiffuseColor':\n          parameters.map = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'DisplacementColor':\n          parameters.displacementMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'EmissiveColor':\n          parameters.emissiveMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'NormalMap':\n          parameters.normalMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'ReflectionColor':\n          parameters.envMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          parameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n          break;\n\n        case 'SpecularColor':\n          parameters.specularMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          break;\n\n        case 'TransparentColor':\n          parameters.alphaMap = getTexture(FBXTree, textureMap, child.ID, connections);\n          parameters.transparent = true;\n          break;\n\n        case 'AmbientColor':\n        case 'ShininessExponent': // AKA glossiness map\n\n        case 'SpecularFactor': // AKA specularLevel\n\n        case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\n        default:\n          console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n          break;\n      }\n    });\n    return parameters;\n  } // get a texture from the textureMap for use by a material.\n\n\n  function getTexture(FBXTree, textureMap, id, connections) {\n    // if the texture is a layered texture, just use the first layer and issue a warning\n    if ('LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture) {\n      console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n      id = connections.get(id).children[0].ID;\n    }\n\n    return textureMap.get(id);\n  } // Parse nodes in FBXTree.Objects.Deformer\n  // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n  // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\n\n  function parseDeformers(FBXTree, connections) {\n    var skeletons = {};\n    var morphTargets = {};\n\n    if ('Deformer' in FBXTree.Objects) {\n      var DeformerNodes = FBXTree.Objects.Deformer;\n\n      for (var nodeID in DeformerNodes) {\n        var deformerNode = DeformerNodes[nodeID];\n        var relationships = connections.get(parseInt(nodeID));\n\n        if (deformerNode.attrType === 'Skin') {\n          var skeleton = parseSkeleton(relationships, DeformerNodes);\n          skeleton.ID = nodeID;\n          if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n          skeleton.geometryID = relationships.parents[0].ID;\n          skeletons[nodeID] = skeleton;\n        } else if (deformerNode.attrType === 'BlendShape') {\n          var morphTarget = {\n            id: nodeID\n          };\n          morphTarget.rawTargets = parseMorphTargets(relationships, deformerNode, DeformerNodes, connections, FBXTree);\n          morphTarget.id = nodeID;\n          if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n          morphTarget.parentGeoID = relationships.parents[0].ID;\n          morphTargets[nodeID] = morphTarget;\n        }\n      }\n    }\n\n    return {\n      skeletons: skeletons,\n      morphTargets: morphTargets\n    };\n  } // Parse single nodes in FBXTree.Objects.Deformer\n  // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n  // Each skin node represents a skeleton and each cluster node represents a bone\n\n\n  function parseSkeleton(connections, deformerNodes) {\n    var rawBones = [];\n    connections.children.forEach(function (child) {\n      var boneNode = deformerNodes[child.ID];\n      if (boneNode.attrType !== 'Cluster') return;\n      var rawBone = {\n        ID: child.ID,\n        indices: [],\n        weights: [],\n        transform: new THREE.Matrix4().fromArray(boneNode.Transform.a),\n        transformLink: new THREE.Matrix4().fromArray(boneNode.TransformLink.a),\n        linkMode: boneNode.Mode\n      };\n\n      if ('Indexes' in boneNode) {\n        rawBone.indices = boneNode.Indexes.a;\n        rawBone.weights = boneNode.Weights.a;\n      }\n\n      rawBones.push(rawBone);\n    });\n    return {\n      rawBones: rawBones,\n      bones: []\n    };\n  } // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\n\n  function parseMorphTargets(relationships, deformerNode, deformerNodes, connections) {\n    var rawMorphTargets = [];\n\n    for (var i = 0; i < relationships.children.length; i++) {\n      if (i === 8) {\n        console.warn('FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.');\n        break;\n      }\n\n      var child = relationships.children[i];\n      var morphTargetNode = deformerNodes[child.ID];\n      var rawMorphTarget = {\n        name: morphTargetNode.attrName,\n        initialWeight: morphTargetNode.DeformPercent,\n        id: morphTargetNode.id,\n        fullWeights: morphTargetNode.FullWeights.a\n      };\n      if (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n      var targetRelationships = connections.get(parseInt(child.ID));\n      targetRelationships.children.forEach(function (child) {\n        if (child.relationship === 'DeformPercent') {\n          // TODO: animation of morph targets is currently unsupported\n          rawMorphTarget.weightCurveID = child.ID; // weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n        } else {\n          rawMorphTarget.geoID = child.ID; // morphGeo = FBXTree.Objects.Geometry[ geoID ];\n        }\n      });\n      rawMorphTargets.push(rawMorphTarget);\n    }\n\n    return rawMorphTargets;\n  } // Parse nodes in FBXTree.Objects.Geometry\n\n\n  function parseGeometries(FBXTree, connections, deformers) {\n    var geometryMap = new Map();\n\n    if ('Geometry' in FBXTree.Objects) {\n      var geoNodes = FBXTree.Objects.Geometry;\n\n      for (var nodeID in geoNodes) {\n        var relationships = connections.get(parseInt(nodeID));\n        var geo = parseGeometry(FBXTree, relationships, geoNodes[nodeID], deformers);\n        geometryMap.set(parseInt(nodeID), geo);\n      }\n    }\n\n    return geometryMap;\n  } // Parse single node in FBXTree.Objects.Geometry\n\n\n  function parseGeometry(FBXTree, relationships, geoNode, deformers) {\n    switch (geoNode.attrType) {\n      case 'Mesh':\n        return parseMeshGeometry(FBXTree, relationships, geoNode, deformers);\n        break;\n\n      case 'NurbsCurve':\n        return parseNurbsGeometry(geoNode);\n        break;\n    }\n  } // Parse single node mesh geometry in FBXTree.Objects.Geometry\n\n\n  function parseMeshGeometry(FBXTree, relationships, geoNode, deformers) {\n    var skeletons = deformers.skeletons;\n    var morphTargets = deformers.morphTargets;\n    var modelNodes = relationships.parents.map(function (parent) {\n      return FBXTree.Objects.Model[parent.ID];\n    }); // don't create geometry if it is not associated with any models\n\n    if (modelNodes.length === 0) return;\n    var skeleton = relationships.children.reduce(function (skeleton, child) {\n      if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n      return skeleton;\n    }, null);\n    var morphTarget = relationships.children.reduce(function (morphTarget, child) {\n      if (morphTargets[child.ID] !== undefined) morphTarget = morphTargets[child.ID];\n      return morphTarget;\n    }, null);\n    var preTransform = new THREE.Matrix4(); // TODO: if there is more than one model associated with the geometry, AND the models have\n    // different geometric transforms, then this will cause problems\n    // if ( modelNodes.length > 1 ) { }\n    // For now just assume one model and get the preRotations from that\n\n    var modelNode = modelNodes[0];\n\n    if ('GeometricRotation' in modelNode) {\n      var array = modelNode.GeometricRotation.value.map(THREE.Math.degToRad);\n      array[3] = 'ZYX';\n      preTransform.makeRotationFromEuler(new THREE.Euler().fromArray(array));\n    }\n\n    if ('GeometricTranslation' in modelNode) {\n      preTransform.setPosition(new THREE.Vector3().fromArray(modelNode.GeometricTranslation.value));\n    }\n\n    if ('GeometricScaling' in modelNode) {\n      preTransform.scale(new THREE.Vector3().fromArray(modelNode.GeometricScaling.value));\n    }\n\n    return genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform);\n  } // Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\n\n  function genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform) {\n    var geo = new THREE.BufferGeometry();\n    if (geoNode.attrName) geo.name = geoNode.attrName;\n    var geoInfo = getGeoInfo(geoNode, skeleton);\n    var buffers = genBuffers(geoInfo);\n    var positionAttribute = new THREE.Float32BufferAttribute(buffers.vertex, 3);\n    preTransform.applyToBufferAttribute(positionAttribute);\n    geo.addAttribute('position', positionAttribute);\n\n    if (buffers.colors.length > 0) {\n      geo.addAttribute('color', new THREE.Float32BufferAttribute(buffers.colors, 3));\n    }\n\n    if (skeleton) {\n      geo.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffers.weightsIndices, 4));\n      geo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffers.vertexWeights, 4)); // used later to bind the skeleton to the model\n\n      geo.FBX_Deformer = skeleton;\n    }\n\n    if (buffers.normal.length > 0) {\n      var normalAttribute = new THREE.Float32BufferAttribute(buffers.normal, 3);\n      var normalMatrix = new THREE.Matrix3().getNormalMatrix(preTransform);\n      normalMatrix.applyToBufferAttribute(normalAttribute);\n      geo.addAttribute('normal', normalAttribute);\n    }\n\n    buffers.uvs.forEach(function (uvBuffer, i) {\n      // subsequent uv buffers are called 'uv1', 'uv2', ...\n      var name = 'uv' + (i + 1).toString(); // the first uv buffer is just called 'uv'\n\n      if (i === 0) {\n        name = 'uv';\n      }\n\n      geo.addAttribute(name, new THREE.Float32BufferAttribute(buffers.uvs[i], 2));\n    });\n\n    if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n      // Convert the material indices of each vertex into rendering groups on the geometry.\n      var prevMaterialIndex = buffers.materialIndex[0];\n      var startIndex = 0;\n      buffers.materialIndex.forEach(function (currentIndex, i) {\n        if (currentIndex !== prevMaterialIndex) {\n          geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n          prevMaterialIndex = currentIndex;\n          startIndex = i;\n        }\n      }); // the loop above doesn't add the last group, do that here.\n\n      if (geo.groups.length > 0) {\n        var lastGroup = geo.groups[geo.groups.length - 1];\n        var lastIndex = lastGroup.start + lastGroup.count;\n\n        if (lastIndex !== buffers.materialIndex.length) {\n          geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n        }\n      } // case where there are multiple materials but the whole geometry is only\n      // using one of them\n\n\n      if (geo.groups.length === 0) {\n        geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n      }\n    }\n\n    addMorphTargets(FBXTree, geo, geoNode, morphTarget, preTransform);\n    return geo;\n  }\n\n  function getGeoInfo(geoNode, skeleton) {\n    var geoInfo = {};\n    geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n    geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n\n    if (geoNode.LayerElementColor) {\n      geoInfo.color = getColors(geoNode.LayerElementColor[0]);\n    }\n\n    if (geoNode.LayerElementMaterial) {\n      geoInfo.material = getMaterials(geoNode.LayerElementMaterial[0]);\n    }\n\n    if (geoNode.LayerElementNormal) {\n      geoInfo.normal = getNormals(geoNode.LayerElementNormal[0]);\n    }\n\n    if (geoNode.LayerElementUV) {\n      geoInfo.uv = [];\n      var i = 0;\n\n      while (geoNode.LayerElementUV[i]) {\n        geoInfo.uv.push(getUVs(geoNode.LayerElementUV[i]));\n        i++;\n      }\n    }\n\n    geoInfo.weightTable = {};\n\n    if (skeleton !== null) {\n      geoInfo.skeleton = skeleton;\n      skeleton.rawBones.forEach(function (rawBone, i) {\n        // loop over the bone's vertex indices and weights\n        rawBone.indices.forEach(function (index, j) {\n          if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n          geoInfo.weightTable[index].push({\n            id: i,\n            weight: rawBone.weights[j]\n          });\n        });\n      });\n    }\n\n    return geoInfo;\n  }\n\n  function genBuffers(geoInfo) {\n    var buffers = {\n      vertex: [],\n      normal: [],\n      colors: [],\n      uvs: [],\n      materialIndex: [],\n      vertexWeights: [],\n      weightsIndices: []\n    };\n    var polygonIndex = 0;\n    var faceLength = 0;\n    var displayedWeightsWarning = false; // these will hold data for a single face\n\n    var facePositionIndexes = [];\n    var faceNormals = [];\n    var faceColors = [];\n    var faceUVs = [];\n    var faceWeights = [];\n    var faceWeightIndices = [];\n    geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n      var endOfFace = false; // Face index and vertex index arrays are combined in a single array\n      // A cube with quad faces looks like this:\n      // PolygonVertexIndex: *24 {\n      //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n      //  }\n      // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n      // to find index of last vertex bit shift the index: ^ - 1\n\n      if (vertexIndex < 0) {\n        vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\n        endOfFace = true;\n      }\n\n      var weightIndices = [];\n      var weights = [];\n      facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n      if (geoInfo.color) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n        faceColors.push(data[0], data[1], data[2]);\n      }\n\n      if (geoInfo.skeleton) {\n        if (geoInfo.weightTable[vertexIndex] !== undefined) {\n          geoInfo.weightTable[vertexIndex].forEach(function (wt) {\n            weights.push(wt.weight);\n            weightIndices.push(wt.id);\n          });\n        }\n\n        if (weights.length > 4) {\n          if (!displayedWeightsWarning) {\n            console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n            displayedWeightsWarning = true;\n          }\n\n          var wIndex = [0, 0, 0, 0];\n          var Weight = [0, 0, 0, 0];\n          weights.forEach(function (weight, weightIndex) {\n            var currentWeight = weight;\n            var currentIndex = weightIndices[weightIndex];\n            Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n              if (currentWeight > comparedWeight) {\n                comparedWeightArray[comparedWeightIndex] = currentWeight;\n                currentWeight = comparedWeight;\n                var tmp = wIndex[comparedWeightIndex];\n                wIndex[comparedWeightIndex] = currentIndex;\n                currentIndex = tmp;\n              }\n            });\n          });\n          weightIndices = wIndex;\n          weights = Weight;\n        } // if the weight array is shorter than 4 pad with 0s\n\n\n        while (weights.length < 4) {\n          weights.push(0);\n          weightIndices.push(0);\n        }\n\n        for (var i = 0; i < 4; ++i) {\n          faceWeights.push(weights[i]);\n          faceWeightIndices.push(weightIndices[i]);\n        }\n      }\n\n      if (geoInfo.normal) {\n        var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n        faceNormals.push(data[0], data[1], data[2]);\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        var materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, i) {\n          var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n\n          if (faceUVs[i] === undefined) {\n            faceUVs[i] = [];\n          }\n\n          faceUVs[i].push(data[0]);\n          faceUVs[i].push(data[1]);\n        });\n      }\n\n      faceLength++;\n\n      if (endOfFace) {\n        genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n        polygonIndex++;\n        faceLength = 0; // reset arrays for the next face\n\n        facePositionIndexes = [];\n        faceNormals = [];\n        faceColors = [];\n        faceUVs = [];\n        faceWeights = [];\n        faceWeightIndices = [];\n      }\n    });\n    return buffers;\n  } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\n\n  function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n    for (var i = 2; i < faceLength; i++) {\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n      buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n\n      if (geoInfo.skeleton) {\n        buffers.vertexWeights.push(faceWeights[0]);\n        buffers.vertexWeights.push(faceWeights[1]);\n        buffers.vertexWeights.push(faceWeights[2]);\n        buffers.vertexWeights.push(faceWeights[3]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n        buffers.vertexWeights.push(faceWeights[i * 4]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n        buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[0]);\n        buffers.weightsIndices.push(faceWeightIndices[1]);\n        buffers.weightsIndices.push(faceWeightIndices[2]);\n        buffers.weightsIndices.push(faceWeightIndices[3]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n        buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n      }\n\n      if (geoInfo.color) {\n        buffers.colors.push(faceColors[0]);\n        buffers.colors.push(faceColors[1]);\n        buffers.colors.push(faceColors[2]);\n        buffers.colors.push(faceColors[(i - 1) * 3]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n        buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n        buffers.colors.push(faceColors[i * 3]);\n        buffers.colors.push(faceColors[i * 3 + 1]);\n        buffers.colors.push(faceColors[i * 3 + 2]);\n      }\n\n      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n        buffers.materialIndex.push(materialIndex);\n      }\n\n      if (geoInfo.normal) {\n        buffers.normal.push(faceNormals[0]);\n        buffers.normal.push(faceNormals[1]);\n        buffers.normal.push(faceNormals[2]);\n        buffers.normal.push(faceNormals[(i - 1) * 3]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n        buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n        buffers.normal.push(faceNormals[i * 3]);\n        buffers.normal.push(faceNormals[i * 3 + 1]);\n        buffers.normal.push(faceNormals[i * 3 + 2]);\n      }\n\n      if (geoInfo.uv) {\n        geoInfo.uv.forEach(function (uv, j) {\n          if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n          buffers.uvs[j].push(faceUVs[j][0]);\n          buffers.uvs[j].push(faceUVs[j][1]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n          buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n          buffers.uvs[j].push(faceUVs[j][i * 2]);\n          buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n        });\n      }\n    }\n  }\n\n  function addMorphTargets(FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform) {\n    if (morphTarget === null) return;\n    parentGeo.morphAttributes.position = [];\n    parentGeo.morphAttributes.normal = [];\n    morphTarget.rawTargets.forEach(function (rawTarget) {\n      var morphGeoNode = FBXTree.Objects.Geometry[rawTarget.geoID];\n\n      if (morphGeoNode !== undefined) {\n        genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform);\n      }\n    });\n  } // a morph geometry node is similar to a standard  node, and the node is also contained\n  // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n  // and a special attribute Index defining which vertices of the original geometry are affected\n  // Normal and position attributes only have data for the vertices that are affected by the morph\n\n\n  function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform) {\n    var morphGeo = new THREE.BufferGeometry();\n    if (morphGeoNode.attrName) morphGeo.name = morphGeoNode.attrName;\n    var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : []; // make a copy of the parent's vertex positions\n\n    var vertexPositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a.slice() : [];\n    var morphPositions = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n    var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n\n    for (var i = 0; i < indices.length; i++) {\n      var morphIndex = indices[i] * 3; // FBX format uses blend shapes rather than morph targets. This can be converted\n      // by additively combining the blend shape positions with the original geometry's positions\n\n      vertexPositions[morphIndex] += morphPositions[i * 3];\n      vertexPositions[morphIndex + 1] += morphPositions[i * 3 + 1];\n      vertexPositions[morphIndex + 2] += morphPositions[i * 3 + 2];\n    } // TODO: add morph normal support\n\n\n    var morphGeoInfo = {\n      vertexIndices: vertexIndices,\n      vertexPositions: vertexPositions\n    };\n    var morphBuffers = genBuffers(morphGeoInfo);\n    var positionAttribute = new THREE.Float32BufferAttribute(morphBuffers.vertex, 3);\n    positionAttribute.name = morphGeoNode.attrName;\n    preTransform.applyToBufferAttribute(positionAttribute);\n    parentGeo.morphAttributes.position.push(positionAttribute);\n  } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\n\n  function getNormals(NormalNode) {\n    var mappingType = NormalNode.MappingInformationType;\n    var referenceType = NormalNode.ReferenceInformationType;\n    var buffer = NormalNode.Normals.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      if ('NormalIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalIndex.a;\n      } else if ('NormalsIndex' in NormalNode) {\n        indexBuffer = NormalNode.NormalsIndex.a;\n      }\n    }\n\n    return {\n      dataSize: 3,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\n\n  function getUVs(UVNode) {\n    var mappingType = UVNode.MappingInformationType;\n    var referenceType = UVNode.ReferenceInformationType;\n    var buffer = UVNode.UV.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = UVNode.UVIndex.a;\n    }\n\n    return {\n      dataSize: 2,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\n\n  function getColors(ColorNode) {\n    var mappingType = ColorNode.MappingInformationType;\n    var referenceType = ColorNode.ReferenceInformationType;\n    var buffer = ColorNode.Colors.a;\n    var indexBuffer = [];\n\n    if (referenceType === 'IndexToDirect') {\n      indexBuffer = ColorNode.ColorIndex.a;\n    }\n\n    return {\n      dataSize: 4,\n      buffer: buffer,\n      indices: indexBuffer,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\n\n  function getMaterials(MaterialNode) {\n    var mappingType = MaterialNode.MappingInformationType;\n    var referenceType = MaterialNode.ReferenceInformationType;\n\n    if (mappingType === 'NoMappingInformation') {\n      return {\n        dataSize: 1,\n        buffer: [0],\n        indices: [0],\n        mappingType: 'AllSame',\n        referenceType: referenceType\n      };\n    }\n\n    var materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n    // we expect.So we create an intermediate buffer that points to the index in the buffer,\n    // for conforming with the other functions we've written for other data.\n\n    var materialIndices = [];\n\n    for (var i = 0; i < materialIndexBuffer.length; ++i) {\n      materialIndices.push(i);\n    }\n\n    return {\n      dataSize: 1,\n      buffer: materialIndexBuffer,\n      indices: materialIndices,\n      mappingType: mappingType,\n      referenceType: referenceType\n    };\n  }\n\n  var dataArray = [];\n\n  function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n    var index;\n\n    switch (infoObject.mappingType) {\n      case 'ByPolygonVertex':\n        index = polygonVertexIndex;\n        break;\n\n      case 'ByPolygon':\n        index = polygonIndex;\n        break;\n\n      case 'ByVertice':\n        index = vertexIndex;\n        break;\n\n      case 'AllSame':\n        index = infoObject.indices[0];\n        break;\n\n      default:\n        console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n    }\n\n    if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n    var from = index * infoObject.dataSize;\n    var to = from + infoObject.dataSize;\n    return slice(dataArray, infoObject.buffer, from, to);\n  } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\n\n  function parseNurbsGeometry(geoNode) {\n    if (THREE.NURBSCurve === undefined) {\n      console.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n      return new THREE.BufferGeometry();\n    }\n\n    var order = parseInt(geoNode.Order);\n\n    if (isNaN(order)) {\n      console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n      return new THREE.BufferGeometry();\n    }\n\n    var degree = order - 1;\n    var knots = geoNode.KnotVector.a;\n    var controlPoints = [];\n    var pointsValues = geoNode.Points.a;\n\n    for (var i = 0, l = pointsValues.length; i < l; i += 4) {\n      controlPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n    }\n\n    var startKnot, endKnot;\n\n    if (geoNode.Form === 'Closed') {\n      controlPoints.push(controlPoints[0]);\n    } else if (geoNode.Form === 'Periodic') {\n      startKnot = degree;\n      endKnot = knots.length - 1 - startKnot;\n\n      for (var i = 0; i < degree; ++i) {\n        controlPoints.push(controlPoints[i]);\n      }\n    }\n\n    var curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n    var vertices = curve.getPoints(controlPoints.length * 7);\n    var positions = new Float32Array(vertices.length * 3);\n    vertices.forEach(function (vertex, i) {\n      vertex.toArray(positions, i * 3);\n    });\n    var geometry = new THREE.BufferGeometry();\n    geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n    return geometry;\n  } // create the main THREE.Group() to be returned by the loader\n\n\n  function parseScene(FBXTree, connections, skeletons, geometryMap, materialMap) {\n    var sceneGraph = new THREE.Group();\n    var modelMap = parseModels(FBXTree, skeletons, geometryMap, materialMap, connections);\n    var modelNodes = FBXTree.Objects.Model;\n    modelMap.forEach(function (model) {\n      var modelNode = modelNodes[model.ID];\n      setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph);\n      var parentConnections = connections.get(model.ID).parents;\n      parentConnections.forEach(function (connection) {\n        var parent = modelMap.get(connection.ID);\n        if (parent !== undefined) parent.add(model);\n      });\n\n      if (model.parent === null) {\n        sceneGraph.add(model);\n      }\n    });\n    bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections);\n    addAnimations(FBXTree, connections, sceneGraph);\n    createAmbientLight(FBXTree, sceneGraph);\n    return sceneGraph;\n  } // parse nodes in FBXTree.Objects.Model\n\n\n  function parseModels(FBXTree, skeletons, geometryMap, materialMap, connections) {\n    var modelMap = new Map();\n    var modelNodes = FBXTree.Objects.Model;\n\n    for (var nodeID in modelNodes) {\n      var id = parseInt(nodeID);\n      var node = modelNodes[nodeID];\n      var relationships = connections.get(id);\n      var model = buildSkeleton(relationships, skeletons, id, node.attrName);\n\n      if (!model) {\n        switch (node.attrType) {\n          case 'Camera':\n            model = createCamera(FBXTree, relationships);\n            break;\n\n          case 'Light':\n            model = createLight(FBXTree, relationships);\n            break;\n\n          case 'Mesh':\n            model = createMesh(FBXTree, relationships, geometryMap, materialMap);\n            break;\n\n          case 'NurbsCurve':\n            model = createCurve(relationships, geometryMap);\n            break;\n\n          case 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n\n          case 'Null':\n          default:\n            model = new THREE.Group();\n            break;\n        }\n\n        model.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n        model.ID = id;\n      }\n\n      setModelTransforms(FBXTree, model, node);\n      modelMap.set(id, model);\n    }\n\n    return modelMap;\n  }\n\n  function buildSkeleton(relationships, skeletons, id, name) {\n    var bone = null;\n    relationships.parents.forEach(function (parent) {\n      for (var ID in skeletons) {\n        var skeleton = skeletons[ID];\n        skeleton.rawBones.forEach(function (rawBone, i) {\n          if (rawBone.ID === parent.ID) {\n            var subBone = bone;\n            bone = new THREE.Bone();\n            bone.matrixWorld.copy(rawBone.transformLink); // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\n            bone.name = THREE.PropertyBinding.sanitizeNodeName(name);\n            bone.ID = id;\n            skeleton.bones[i] = bone; // In cases where a bone is shared between multiple meshes\n            // duplicate the bone here and and it as a child of the first bone\n\n            if (subBone !== null) {\n              bone.add(subBone);\n            }\n          }\n        });\n      }\n    });\n    return bone;\n  } // create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\n\n  function createCamera(FBXTree, relationships) {\n    var model;\n    var cameraAttribute;\n    relationships.children.forEach(function (child) {\n      var attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n      if (attr !== undefined) {\n        cameraAttribute = attr;\n      }\n    });\n\n    if (cameraAttribute === undefined) {\n      model = new THREE.Object3D();\n    } else {\n      var type = 0;\n\n      if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n        type = 1;\n      }\n\n      var nearClippingPlane = 1;\n\n      if (cameraAttribute.NearPlane !== undefined) {\n        nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n      }\n\n      var farClippingPlane = 1000;\n\n      if (cameraAttribute.FarPlane !== undefined) {\n        farClippingPlane = cameraAttribute.FarPlane.value / 1000;\n      }\n\n      var width = window.innerWidth;\n      var height = window.innerHeight;\n\n      if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n        width = cameraAttribute.AspectWidth.value;\n        height = cameraAttribute.AspectHeight.value;\n      }\n\n      var aspect = width / height;\n      var fov = 45;\n\n      if (cameraAttribute.FieldOfView !== undefined) {\n        fov = cameraAttribute.FieldOfView.value;\n      }\n\n      var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n      switch (type) {\n        case 0:\n          // Perspective\n          model = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n          if (focalLength !== null) model.setFocalLength(focalLength);\n          break;\n\n        case 1:\n          // Orthographic\n          model = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n          break;\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n          model = new THREE.Object3D();\n          break;\n      }\n    }\n\n    return model;\n  } // Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\n\n  function createLight(FBXTree, relationships) {\n    var model;\n    var lightAttribute;\n    relationships.children.forEach(function (child) {\n      var attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n      if (attr !== undefined) {\n        lightAttribute = attr;\n      }\n    });\n\n    if (lightAttribute === undefined) {\n      model = new THREE.Object3D();\n    } else {\n      var type; // LightType can be undefined for Point lights\n\n      if (lightAttribute.LightType === undefined) {\n        type = 0;\n      } else {\n        type = lightAttribute.LightType.value;\n      }\n\n      var color = 0xffffff;\n\n      if (lightAttribute.Color !== undefined) {\n        color = new THREE.Color().fromArray(lightAttribute.Color.value);\n      }\n\n      var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled\n\n      if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n        intensity = 0;\n      }\n\n      var distance = 0;\n\n      if (lightAttribute.FarAttenuationEnd !== undefined) {\n        if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n          distance = 0;\n        } else {\n          distance = lightAttribute.FarAttenuationEnd.value;\n        }\n      } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\n\n      var decay = 1;\n\n      switch (type) {\n        case 0:\n          // Point\n          model = new THREE.PointLight(color, intensity, distance, decay);\n          break;\n\n        case 1:\n          // Directional\n          model = new THREE.DirectionalLight(color, intensity);\n          break;\n\n        case 2:\n          // Spot\n          var angle = Math.PI / 3;\n\n          if (lightAttribute.InnerAngle !== undefined) {\n            angle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n          }\n\n          var penumbra = 0;\n\n          if (lightAttribute.OuterAngle !== undefined) {\n            // TODO: this is not correct - FBX calculates outer and inner angle in degrees\n            // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n            // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n            penumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n            penumbra = Math.max(penumbra, 1);\n          }\n\n          model = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n          break;\n\n        default:\n          console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n          model = new THREE.PointLight(color, intensity);\n          break;\n      }\n\n      if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n        model.castShadow = true;\n      }\n    }\n\n    return model;\n  }\n\n  function createMesh(FBXTree, relationships, geometryMap, materialMap) {\n    var model;\n    var geometry = null;\n    var material = null;\n    var materials = []; // get geometry and materials(s) from connections\n\n    relationships.children.forEach(function (child) {\n      if (geometryMap.has(child.ID)) {\n        geometry = geometryMap.get(child.ID);\n      }\n\n      if (materialMap.has(child.ID)) {\n        materials.push(materialMap.get(child.ID));\n      }\n    });\n\n    if (materials.length > 1) {\n      material = materials;\n    } else if (materials.length > 0) {\n      material = materials[0];\n    } else {\n      material = new THREE.MeshPhongMaterial({\n        color: 0xcccccc\n      });\n      materials.push(material);\n    }\n\n    if ('color' in geometry.attributes) {\n      materials.forEach(function (material) {\n        material.vertexColors = THREE.VertexColors;\n      });\n    }\n\n    if (geometry.FBX_Deformer) {\n      materials.forEach(function (material) {\n        material.skinning = true;\n      });\n      model = new THREE.SkinnedMesh(geometry, material);\n    } else {\n      model = new THREE.Mesh(geometry, material);\n    }\n\n    return model;\n  }\n\n  function createCurve(relationships, geometryMap) {\n    var geometry = relationships.children.reduce(function (geo, child) {\n      if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n      return geo;\n    }, null); // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\n    var material = new THREE.LineBasicMaterial({\n      color: 0x3300ff,\n      linewidth: 1\n    });\n    return new THREE.Line(geometry, material);\n  } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\n\n  function createAmbientLight(FBXTree, sceneGraph) {\n    if ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings) {\n      var ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n      var r = ambientColor[0];\n      var g = ambientColor[1];\n      var b = ambientColor[2];\n\n      if (r !== 0 || g !== 0 || b !== 0) {\n        var color = new THREE.Color(r, g, b);\n        sceneGraph.add(new THREE.AmbientLight(color, 1));\n      }\n    }\n  }\n\n  function setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph) {\n    if ('LookAtProperty' in modelNode) {\n      var children = connections.get(model.ID).children;\n      children.forEach(function (child) {\n        if (child.relationship === 'LookAtProperty') {\n          var lookAtTarget = FBXTree.Objects.Model[child.ID];\n\n          if ('Lcl_Translation' in lookAtTarget) {\n            var pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight\n\n            if (model.target !== undefined) {\n              model.target.position.fromArray(pos);\n              sceneGraph.add(model.target);\n            } else {\n              // Cameras and other Object3Ds\n              model.lookAt(new THREE.Vector3().fromArray(pos));\n            }\n          }\n        }\n      });\n    }\n  } // parse the model node for transform details and apply them to the model\n\n\n  function setModelTransforms(FBXTree, model, modelNode) {\n    // http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n    if ('RotationOrder' in modelNode) {\n      var enums = ['XYZ', // default\n      'XZY', 'YZX', 'ZXY', 'YXZ', 'ZYX', 'SphericXYZ'];\n      var value = parseInt(modelNode.RotationOrder.value, 10);\n\n      if (value > 0 && value < 6) {\n        // model.rotation.order = enums[ value ];\n        // Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n        console.warn('THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[value]);\n      } else if (value === 6) {\n        console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n      }\n    }\n\n    if ('Lcl_Translation' in modelNode) {\n      model.position.fromArray(modelNode.Lcl_Translation.value);\n    }\n\n    if ('Lcl_Rotation' in modelNode) {\n      var rotation = modelNode.Lcl_Rotation.value.map(THREE.Math.degToRad);\n      rotation.push('ZYX');\n      model.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));\n    }\n\n    if ('Lcl_Scaling' in modelNode) {\n      model.scale.fromArray(modelNode.Lcl_Scaling.value);\n    }\n\n    if ('PreRotation' in modelNode) {\n      var array = modelNode.PreRotation.value.map(THREE.Math.degToRad);\n      array[3] = 'ZYX';\n      var preRotations = new THREE.Euler().fromArray(array);\n      preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n      model.quaternion.premultiply(preRotations);\n    }\n  }\n\n  function bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections) {\n    if (isEmpty(skeletons)) return;\n    var bindMatrices = parsePoseNodes(FBXTree);\n\n    for (var ID in skeletons) {\n      var skeleton = skeletons[ID];\n      var parents = connections.get(parseInt(skeleton.ID)).parents;\n      parents.forEach(function (parent) {\n        if (geometryMap.has(parent.ID)) {\n          var geoID = parent.ID;\n          var geoRelationships = connections.get(geoID);\n          geoRelationships.parents.forEach(function (geoConnParent) {\n            if (modelMap.has(geoConnParent.ID)) {\n              var model = modelMap.get(geoConnParent.ID);\n              model.bind(new THREE.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  function isEmpty(map) {\n    for (var key in map) {\n      if (map.hasOwnProperty(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function parsePoseNodes(FBXTree) {\n    var bindMatrices = {};\n\n    if ('Pose' in FBXTree.Objects) {\n      var BindPoseNode = FBXTree.Objects.Pose;\n\n      for (var nodeID in BindPoseNode) {\n        if (BindPoseNode[nodeID].attrType === 'BindPose') {\n          var poseNodes = BindPoseNode[nodeID].PoseNode;\n\n          if (Array.isArray(poseNodes)) {\n            poseNodes.forEach(function (poseNode) {\n              bindMatrices[poseNode.Node] = new THREE.Matrix4().fromArray(poseNode.Matrix.a);\n            });\n          } else {\n            bindMatrices[poseNodes.Node] = new THREE.Matrix4().fromArray(poseNodes.Matrix.a);\n          }\n        }\n      }\n    }\n\n    return bindMatrices;\n  }\n\n  function parseAnimations(FBXTree, connections) {\n    // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n    // if this is undefined we can safely assume there are no animations\n    if (FBXTree.Objects.AnimationCurve === undefined) return undefined;\n    var curveNodesMap = parseAnimationCurveNodes(FBXTree);\n    parseAnimationCurves(FBXTree, connections, curveNodesMap);\n    var layersMap = parseAnimationLayers(FBXTree, connections, curveNodesMap);\n    var rawClips = parseAnimStacks(FBXTree, connections, layersMap);\n    return rawClips;\n  } // parse nodes in FBXTree.Objects.AnimationCurveNode\n  // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n  // and is referenced by an AnimationLayer\n\n\n  function parseAnimationCurveNodes(FBXTree) {\n    var rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n    var curveNodesMap = new Map();\n\n    for (var nodeID in rawCurveNodes) {\n      var rawCurveNode = rawCurveNodes[nodeID];\n\n      if (rawCurveNode.attrName.match(/S|R|T/) !== null) {\n        var curveNode = {\n          id: rawCurveNode.id,\n          attr: rawCurveNode.attrName,\n          curves: {}\n        };\n        curveNodesMap.set(curveNode.id, curveNode);\n      }\n    }\n\n    return curveNodesMap;\n  } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n  // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n  // axis ( e.g. times and values of x rotation)\n\n\n  function parseAnimationCurves(FBXTree, connections, curveNodesMap) {\n    var rawCurves = FBXTree.Objects.AnimationCurve;\n\n    for (var nodeID in rawCurves) {\n      var animationCurve = {\n        id: rawCurves[nodeID].id,\n        times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n        values: rawCurves[nodeID].KeyValueFloat.a\n      };\n      var relationships = connections.get(animationCurve.id);\n\n      if (relationships !== undefined) {\n        var animationCurveID = relationships.parents[0].ID;\n        var animationCurveRelationship = relationships.parents[0].relationship;\n\n        if (animationCurveRelationship.match(/X/)) {\n          curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Y/)) {\n          curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n        } else if (animationCurveRelationship.match(/Z/)) {\n          curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n        }\n      }\n    }\n  } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n  // to various AnimationCurveNodes and is referenced by an AnimationStack node\n  // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\n\n  function parseAnimationLayers(FBXTree, connections, curveNodesMap) {\n    var rawLayers = FBXTree.Objects.AnimationLayer;\n    var layersMap = new Map();\n\n    for (var nodeID in rawLayers) {\n      var layerCurveNodes = [];\n      var connection = connections.get(parseInt(nodeID));\n\n      if (connection !== undefined) {\n        // all the animationCurveNodes used in the layer\n        var children = connection.children;\n        children.forEach(function (child, i) {\n          if (curveNodesMap.has(child.ID)) {\n            var curveNode = curveNodesMap.get(child.ID); // check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\n            if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n              if (layerCurveNodes[i] === undefined) {\n                var modelID;\n                connections.get(child.ID).parents.forEach(function (parent) {\n                  if (parent.relationship !== undefined) modelID = parent.ID;\n                });\n                var rawModel = FBXTree.Objects.Model[modelID.toString()];\n                var node = {\n                  modelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),\n                  initialPosition: [0, 0, 0],\n                  initialRotation: [0, 0, 0],\n                  initialScale: [1, 1, 1]\n                };\n                if ('Lcl_Translation' in rawModel) node.initialPosition = rawModel.Lcl_Translation.value;\n                if ('Lcl_Rotation' in rawModel) node.initialRotation = rawModel.Lcl_Rotation.value;\n                if ('Lcl_Scaling' in rawModel) node.initialScale = rawModel.Lcl_Scaling.value; // if the animated model is pre rotated, we'll have to apply the pre rotations to every\n                // animation value as well\n\n                if ('PreRotation' in rawModel) node.preRotations = rawModel.PreRotation.value;\n                layerCurveNodes[i] = node;\n              }\n\n              layerCurveNodes[i][curveNode.attr] = curveNode;\n            }\n          }\n        });\n        layersMap.set(parseInt(nodeID), layerCurveNodes);\n      }\n    }\n\n    return layersMap;\n  } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n  // hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\n\n  function parseAnimStacks(FBXTree, connections, layersMap) {\n    var rawStacks = FBXTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers\n\n    var rawClips = {};\n\n    for (var nodeID in rawStacks) {\n      var children = connections.get(parseInt(nodeID)).children;\n\n      if (children.length > 1) {\n        // it seems like stacks will always be associated with a single layer. But just in case there are files\n        // where there are multiple layers per stack, we'll display a warning\n        console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n      }\n\n      var layer = layersMap.get(children[0].ID);\n      rawClips[nodeID] = {\n        name: rawStacks[nodeID].attrName,\n        layer: layer\n      };\n    }\n\n    return rawClips;\n  } // take raw animation data from parseAnimations and connect it up to the loaded models\n\n\n  function addAnimations(FBXTree, connections, sceneGraph) {\n    sceneGraph.animations = [];\n    var rawClips = parseAnimations(FBXTree, connections);\n    if (rawClips === undefined) return;\n\n    for (var key in rawClips) {\n      var rawClip = rawClips[key];\n      var clip = addClip(rawClip);\n      sceneGraph.animations.push(clip);\n    }\n  }\n\n  function addClip(rawClip) {\n    var tracks = [];\n    rawClip.layer.forEach(function (rawTracks) {\n      tracks = tracks.concat(generateTracks(rawTracks));\n    });\n    return new THREE.AnimationClip(rawClip.name, -1, tracks);\n  }\n\n  function generateTracks(rawTracks) {\n    var tracks = [];\n\n    if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n      var positionTrack = generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position');\n      if (positionTrack !== undefined) tracks.push(positionTrack);\n    }\n\n    if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n      var rotationTrack = generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations);\n      if (rotationTrack !== undefined) tracks.push(rotationTrack);\n    }\n\n    if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n      var scaleTrack = generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale');\n      if (scaleTrack !== undefined) tracks.push(scaleTrack);\n    }\n\n    return tracks;\n  }\n\n  function generateVectorTrack(modelName, curves, initialValue, type) {\n    var times = getTimesForAllAxes(curves);\n    var values = getKeyframeTrackValues(times, curves, initialValue);\n    return new THREE.VectorKeyframeTrack(modelName + '.' + type, times, values);\n  }\n\n  function generateRotationTrack(modelName, curves, initialValue, preRotations) {\n    if (curves.x !== undefined) {\n      interpolateRotations(curves.x);\n      curves.x.values = curves.x.values.map(THREE.Math.degToRad);\n    }\n\n    if (curves.y !== undefined) {\n      interpolateRotations(curves.y);\n      curves.y.values = curves.y.values.map(THREE.Math.degToRad);\n    }\n\n    if (curves.z !== undefined) {\n      interpolateRotations(curves.z);\n      curves.z.values = curves.z.values.map(THREE.Math.degToRad);\n    }\n\n    var times = getTimesForAllAxes(curves);\n    var values = getKeyframeTrackValues(times, curves, initialValue);\n\n    if (preRotations !== undefined) {\n      preRotations = preRotations.map(THREE.Math.degToRad);\n      preRotations.push('ZYX');\n      preRotations = new THREE.Euler().fromArray(preRotations);\n      preRotations = new THREE.Quaternion().setFromEuler(preRotations);\n    }\n\n    var quaternion = new THREE.Quaternion();\n    var euler = new THREE.Euler();\n    var quaternionValues = [];\n\n    for (var i = 0; i < values.length; i += 3) {\n      euler.set(values[i], values[i + 1], values[i + 2], 'ZYX');\n      quaternion.setFromEuler(euler);\n      if (preRotations !== undefined) quaternion.premultiply(preRotations);\n      quaternion.toArray(quaternionValues, i / 3 * 4);\n    }\n\n    return new THREE.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n  }\n\n  function getKeyframeTrackValues(times, curves, initialValue) {\n    var prevValue = initialValue;\n    var values = [];\n    var xIndex = -1;\n    var yIndex = -1;\n    var zIndex = -1;\n    times.forEach(function (time) {\n      if (curves.x) xIndex = curves.x.times.indexOf(time);\n      if (curves.y) yIndex = curves.y.times.indexOf(time);\n      if (curves.z) zIndex = curves.z.times.indexOf(time); // if there is an x value defined for this frame, use that\n\n      if (xIndex !== -1) {\n        var xValue = curves.x.values[xIndex];\n        values.push(xValue);\n        prevValue[0] = xValue;\n      } else {\n        // otherwise use the x value from the previous frame\n        values.push(prevValue[0]);\n      }\n\n      if (yIndex !== -1) {\n        var yValue = curves.y.values[yIndex];\n        values.push(yValue);\n        prevValue[1] = yValue;\n      } else {\n        values.push(prevValue[1]);\n      }\n\n      if (zIndex !== -1) {\n        var zValue = curves.z.values[zIndex];\n        values.push(zValue);\n        prevValue[2] = zValue;\n      } else {\n        values.push(prevValue[2]);\n      }\n    });\n    return values;\n  } // For all animated objects, times are defined separately for each axis\n  // Here we'll combine the times into one sorted array without duplicates\n\n\n  function getTimesForAllAxes(curves) {\n    var times = []; // first join together the times for each axis, if defined\n\n    if (curves.x !== undefined) times = times.concat(curves.x.times);\n    if (curves.y !== undefined) times = times.concat(curves.y.times);\n    if (curves.z !== undefined) times = times.concat(curves.z.times); // then sort them and remove duplicates\n\n    times = times.sort(function (a, b) {\n      return a - b;\n    }).filter(function (elem, index, array) {\n      return array.indexOf(elem) == index;\n    });\n    return times;\n  } // Rotations are defined as Euler angles which can have values  of any size\n  // These will be converted to quaternions which don't support values greater than\n  // PI, so we'll interpolate large rotations\n\n\n  function interpolateRotations(curve) {\n    for (var i = 1; i < curve.values.length; i++) {\n      var initialValue = curve.values[i - 1];\n      var valuesSpan = curve.values[i] - initialValue;\n      var absoluteSpan = Math.abs(valuesSpan);\n\n      if (absoluteSpan >= 180) {\n        var numSubIntervals = absoluteSpan / 180;\n        var step = valuesSpan / numSubIntervals;\n        var nextValue = initialValue + step;\n        var initialTime = curve.times[i - 1];\n        var timeSpan = curve.times[i] - initialTime;\n        var interval = timeSpan / numSubIntervals;\n        var nextTime = initialTime + interval;\n        var interpolatedTimes = [];\n        var interpolatedValues = [];\n\n        while (nextTime < curve.times[i]) {\n          interpolatedTimes.push(nextTime);\n          nextTime += interval;\n          interpolatedValues.push(nextValue);\n          nextValue += step;\n        }\n\n        curve.times = inject(curve.times, i, interpolatedTimes);\n        curve.values = inject(curve.values, i, interpolatedValues);\n      }\n    }\n  } // parse an FBX file in ASCII format\n\n\n  function TextParser() {}\n\n  Object.assign(TextParser.prototype, {\n    getPrevNode: function getPrevNode() {\n      return this.nodeStack[this.currentIndent - 2];\n    },\n    getCurrentNode: function getCurrentNode() {\n      return this.nodeStack[this.currentIndent - 1];\n    },\n    getCurrentProp: function getCurrentProp() {\n      return this.currentProp;\n    },\n    pushStack: function pushStack(node) {\n      this.nodeStack.push(node);\n      this.currentIndent += 1;\n    },\n    popStack: function popStack() {\n      this.nodeStack.pop();\n      this.currentIndent -= 1;\n    },\n    setCurrentProp: function setCurrentProp(val, name) {\n      this.currentProp = val;\n      this.currentPropName = name;\n    },\n    parse: function parse(text) {\n      this.currentIndent = 0;\n      this.allNodes = new FBXTree();\n      this.nodeStack = [];\n      this.currentProp = [];\n      this.currentPropName = '';\n      var self = this;\n      var split = text.split('\\n');\n      split.forEach(function (line, i) {\n        var matchComment = line.match(/^[\\s\\t]*;/);\n        var matchEmpty = line.match(/^[\\s\\t]*$/);\n        if (matchComment || matchEmpty) return;\n        var matchBeginning = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '');\n        var matchProperty = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n        var matchEnd = line.match('^\\\\t{' + (self.currentIndent - 1) + '}}');\n\n        if (matchBeginning) {\n          self.parseNodeBegin(line, matchBeginning);\n        } else if (matchProperty) {\n          self.parseNodeProperty(line, matchProperty, split[++i]);\n        } else if (matchEnd) {\n          self.popStack();\n        } else if (line.match(/^[^\\s\\t}]/)) {\n          // large arrays are split over multiple lines terminated with a ',' character\n          // if this is encountered the line needs to be joined to the previous line\n          self.parseNodePropertyContinued(line);\n        }\n      });\n      return this.allNodes;\n    },\n    parseNodeBegin: function parseNodeBegin(line, property) {\n      var nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n      var nodeAttrs = property[2].split(',').map(function (attr) {\n        return attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n      });\n      var node = {\n        name: nodeName\n      };\n      var attrs = this.parseNodeAttr(nodeAttrs);\n      var currentNode = this.getCurrentNode(); // a top node\n\n      if (this.currentIndent === 0) {\n        this.allNodes.add(nodeName, node);\n      } else {\n        // a subnode\n        // if the subnode already exists, append it\n        if (nodeName in currentNode) {\n          // special case Pose needs PoseNodes as an array\n          if (nodeName === 'PoseNode') {\n            currentNode.PoseNode.push(node);\n          } else if (currentNode[nodeName].id !== undefined) {\n            currentNode[nodeName] = {};\n            currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n          }\n\n          if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n        } else if (typeof attrs.id === 'number') {\n          currentNode[nodeName] = {};\n          currentNode[nodeName][attrs.id] = node;\n        } else if (nodeName !== 'Properties70') {\n          if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n        }\n      }\n\n      if (typeof attrs.id === 'number') node.id = attrs.id;\n      if (attrs.name !== '') node.attrName = attrs.name;\n      if (attrs.type !== '') node.attrType = attrs.type;\n      this.pushStack(node);\n    },\n    parseNodeAttr: function parseNodeAttr(attrs) {\n      var id = attrs[0];\n\n      if (attrs[0] !== '') {\n        id = parseInt(attrs[0]);\n\n        if (isNaN(id)) {\n          id = attrs[0];\n        }\n      }\n\n      var name = '',\n          type = '';\n\n      if (attrs.length > 1) {\n        name = attrs[1].replace(/^(\\w+)::/, '');\n        type = attrs[2];\n      }\n\n      return {\n        id: id,\n        name: name,\n        type: type\n      };\n    },\n    parseNodeProperty: function parseNodeProperty(line, property, contentLine) {\n      var propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n      var propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim(); // for special case: base64 image data follows \"Content: ,\" line\n      //\tContent: ,\n      //\t \"/9j/4RDaRXhpZgAATU0A...\"\n\n      if (propName === 'Content' && propValue === ',') {\n        propValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n      }\n\n      var currentNode = this.getCurrentNode();\n      var parentName = currentNode.name;\n\n      if (parentName === 'Properties70') {\n        this.parseNodeSpecialProperty(line, propName, propValue);\n        return;\n      } // Connections\n\n\n      if (propName === 'C') {\n        var connProps = propValue.split(',').slice(1);\n        var from = parseInt(connProps[0]);\n        var to = parseInt(connProps[1]);\n        var rest = propValue.split(',').slice(3);\n        rest = rest.map(function (elem) {\n          return elem.trim().replace(/^\"/, '');\n        });\n        propName = 'connections';\n        propValue = [from, to];\n        append(propValue, rest);\n\n        if (currentNode[propName] === undefined) {\n          currentNode[propName] = [];\n        }\n      } // Node\n\n\n      if (propName === 'Node') currentNode.id = propValue; // connections\n\n      if (propName in currentNode && Array.isArray(currentNode[propName])) {\n        currentNode[propName].push(propValue);\n      } else {\n        if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n      }\n\n      this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it\n\n      if (propName === 'a' && propValue.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(propValue);\n      }\n    },\n    parseNodePropertyContinued: function parseNodePropertyContinued(line) {\n      var currentNode = this.getCurrentNode();\n      currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value\n      // so convert the string to an array\n\n      if (line.slice(-1) !== ',') {\n        currentNode.a = parseNumberArray(currentNode.a);\n      }\n    },\n    // parse \"Property70\"\n    parseNodeSpecialProperty: function parseNodeSpecialProperty(line, propName, propValue) {\n      // split this\n      // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n      // into array like below\n      // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n      var props = propValue.split('\",').map(function (prop) {\n        return prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n      });\n      var innerPropName = props[0];\n      var innerPropType1 = props[1];\n      var innerPropType2 = props[2];\n      var innerPropFlag = props[3];\n      var innerPropValue = props[4]; // cast values where needed, otherwise leave as strings\n\n      switch (innerPropType1) {\n        case 'int':\n        case 'enum':\n        case 'bool':\n        case 'ULongLong':\n        case 'double':\n        case 'Number':\n        case 'FieldOfView':\n          innerPropValue = parseFloat(innerPropValue);\n          break;\n\n        case 'Color':\n        case 'ColorRGB':\n        case 'Vector3D':\n        case 'Lcl_Translation':\n        case 'Lcl_Rotation':\n        case 'Lcl_Scaling':\n          innerPropValue = parseNumberArray(innerPropValue);\n          break;\n      } // CAUTION: these props must append to parent's parent\n\n\n      this.getPrevNode()[innerPropName] = {\n        'type': innerPropType1,\n        'type2': innerPropType2,\n        'flag': innerPropFlag,\n        'value': innerPropValue\n      };\n      this.setCurrentProp(this.getPrevNode(), innerPropName);\n    }\n  }); // Parse an FBX file in Binary format\n\n  function BinaryParser() {}\n\n  Object.assign(BinaryParser.prototype, {\n    parse: function parse(buffer) {\n      var reader = new BinaryReader(buffer);\n      reader.skip(23); // skip magic 23 bytes\n\n      var version = reader.getUint32();\n      console.log('THREE.FBXLoader: FBX binary version: ' + version);\n      var allNodes = new FBXTree();\n\n      while (!this.endOfContent(reader)) {\n        var node = this.parseNode(reader, version);\n        if (node !== null) allNodes.add(node.name, node);\n      }\n\n      return allNodes;\n    },\n    // Check if reader has reached the end of content.\n    endOfContent: function endOfContent(reader) {\n      // footer size: 160bytes + 16-byte alignment padding\n      // - 16bytes: magic\n      // - padding til 16-byte alignment (at least 1byte?)\n      //\t(seems like some exporters embed fixed 15 or 16bytes?)\n      // - 4bytes: magic\n      // - 4bytes: version\n      // - 120bytes: zero\n      // - 16bytes: magic\n      if (reader.size() % 16 === 0) {\n        return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n      } else {\n        return reader.getOffset() + 160 + 16 >= reader.size();\n      }\n    },\n    // recursively parse nodes until the end of the file is reached\n    parseNode: function parseNode(reader, version) {\n      var node = {}; // The first three data sizes depends on version.\n\n      var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32(); // note: do not remove this even if you get a linter warning as it moves the buffer forward\n\n      var propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n      var nameLen = reader.getUint8();\n      var name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero\n\n      if (endOffset === 0) return null;\n      var propertyList = [];\n\n      for (var i = 0; i < numProperties; i++) {\n        propertyList.push(this.parseProperty(reader));\n      } // Regards the first three elements in propertyList as id, attrName, and attrType\n\n\n      var id = propertyList.length > 0 ? propertyList[0] : '';\n      var attrName = propertyList.length > 1 ? propertyList[1] : '';\n      var attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property\n      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\n      node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n\n      while (endOffset > reader.getOffset()) {\n        var subNode = this.parseNode(reader, version);\n        if (subNode !== null) this.parseSubNode(name, node, subNode);\n      }\n\n      node.propertyList = propertyList; // raw property list used by parent\n\n      if (typeof id === 'number') node.id = id;\n      if (attrName !== '') node.attrName = attrName;\n      if (attrType !== '') node.attrType = attrType;\n      if (name !== '') node.name = name;\n      return node;\n    },\n    parseSubNode: function parseSubNode(name, node, subNode) {\n      // special case: child node is single property\n      if (subNode.singleProperty === true) {\n        var value = subNode.propertyList[0];\n\n        if (Array.isArray(value)) {\n          node[subNode.name] = subNode;\n          subNode.a = value;\n        } else {\n          node[subNode.name] = value;\n        }\n      } else if (name === 'Connections' && subNode.name === 'C') {\n        var array = [];\n        subNode.propertyList.forEach(function (property, i) {\n          // first Connection is FBX type (OO, OP, etc.). We'll discard these\n          if (i !== 0) array.push(property);\n        });\n\n        if (node.connections === undefined) {\n          node.connections = [];\n        }\n\n        node.connections.push(array);\n      } else if (subNode.name === 'Properties70') {\n        var keys = Object.keys(subNode);\n        keys.forEach(function (key) {\n          node[key] = subNode[key];\n        });\n      } else if (name === 'Properties70' && subNode.name === 'P') {\n        var innerPropName = subNode.propertyList[0];\n        var innerPropType1 = subNode.propertyList[1];\n        var innerPropType2 = subNode.propertyList[2];\n        var innerPropFlag = subNode.propertyList[3];\n        var innerPropValue;\n        if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n        if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n        if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n          innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n        } else {\n          innerPropValue = subNode.propertyList[4];\n        } // this will be copied to parent, see above\n\n\n        node[innerPropName] = {\n          'type': innerPropType1,\n          'type2': innerPropType2,\n          'flag': innerPropFlag,\n          'value': innerPropValue\n        };\n      } else if (node[subNode.name] === undefined) {\n        if (typeof subNode.id === 'number') {\n          node[subNode.name] = {};\n          node[subNode.name][subNode.id] = subNode;\n        } else {\n          node[subNode.name] = subNode;\n        }\n      } else {\n        if (subNode.name === 'PoseNode') {\n          if (!Array.isArray(node[subNode.name])) {\n            node[subNode.name] = [node[subNode.name]];\n          }\n\n          node[subNode.name].push(subNode);\n        } else if (node[subNode.name][subNode.id] === undefined) {\n          node[subNode.name][subNode.id] = subNode;\n        }\n      }\n    },\n    parseProperty: function parseProperty(reader) {\n      var type = reader.getString(1);\n\n      switch (type) {\n        case 'C':\n          return reader.getBoolean();\n\n        case 'D':\n          return reader.getFloat64();\n\n        case 'F':\n          return reader.getFloat32();\n\n        case 'I':\n          return reader.getInt32();\n\n        case 'L':\n          return reader.getInt64();\n\n        case 'R':\n          var length = reader.getUint32();\n          return reader.getArrayBuffer(length);\n\n        case 'S':\n          var length = reader.getUint32();\n          return reader.getString(length);\n\n        case 'Y':\n          return reader.getInt16();\n\n        case 'b':\n        case 'c':\n        case 'd':\n        case 'f':\n        case 'i':\n        case 'l':\n          var arrayLength = reader.getUint32();\n          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\n          var compressedLength = reader.getUint32();\n\n          if (encoding === 0) {\n            switch (type) {\n              case 'b':\n              case 'c':\n                return reader.getBooleanArray(arrayLength);\n\n              case 'd':\n                return reader.getFloat64Array(arrayLength);\n\n              case 'f':\n                return reader.getFloat32Array(arrayLength);\n\n              case 'i':\n                return reader.getInt32Array(arrayLength);\n\n              case 'l':\n                return reader.getInt64Array(arrayLength);\n            }\n          }\n\n          if (window.Zlib === undefined) {\n            console.error('THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js');\n          }\n\n          var inflate = new _inflate_module_min_js__WEBPACK_IMPORTED_MODULE_0__[\"Zlib\"].Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\n          var reader2 = new BinaryReader(inflate.decompress().buffer);\n\n          switch (type) {\n            case 'b':\n            case 'c':\n              return reader2.getBooleanArray(arrayLength);\n\n            case 'd':\n              return reader2.getFloat64Array(arrayLength);\n\n            case 'f':\n              return reader2.getFloat32Array(arrayLength);\n\n            case 'i':\n              return reader2.getInt32Array(arrayLength);\n\n            case 'l':\n              return reader2.getInt64Array(arrayLength);\n          }\n\n        default:\n          throw new Error('THREE.FBXLoader: Unknown property type ' + type);\n      }\n    }\n  });\n\n  function BinaryReader(buffer, littleEndian) {\n    this.dv = new DataView(buffer);\n    this.offset = 0;\n    this.littleEndian = littleEndian !== undefined ? littleEndian : true;\n  }\n\n  Object.assign(BinaryReader.prototype, {\n    getOffset: function getOffset() {\n      return this.offset;\n    },\n    size: function size() {\n      return this.dv.buffer.byteLength;\n    },\n    skip: function skip(length) {\n      this.offset += length;\n    },\n    // seems like true/false representation depends on exporter.\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n    // then sees LSB.\n    getBoolean: function getBoolean() {\n      return (this.getUint8() & 1) === 1;\n    },\n    getBooleanArray: function getBooleanArray(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getBoolean());\n      }\n\n      return a;\n    },\n    getUint8: function getUint8() {\n      var value = this.dv.getUint8(this.offset);\n      this.offset += 1;\n      return value;\n    },\n    getInt16: function getInt16() {\n      var value = this.dv.getInt16(this.offset, this.littleEndian);\n      this.offset += 2;\n      return value;\n    },\n    getInt32: function getInt32() {\n      var value = this.dv.getInt32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getInt32Array: function getInt32Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt32());\n      }\n\n      return a;\n    },\n    getUint32: function getUint32() {\n      var value = this.dv.getUint32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    // JavaScript doesn't support 64-bit integer so calculate this here\n    // 1 << 32 will return 1 so using multiply operation instead here.\n    // There's a possibility that this method returns wrong value if the value\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n    // TODO: safely handle 64-bit integer\n    getInt64: function getInt64() {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      } // calculate negative value\n\n\n      if (high & 0x80000000) {\n        high = ~high & 0xFFFFFFFF;\n        low = ~low & 0xFFFFFFFF;\n        if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n        low = low + 1 & 0xFFFFFFFF;\n        return -(high * 0x100000000 + low);\n      }\n\n      return high * 0x100000000 + low;\n    },\n    getInt64Array: function getInt64Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getInt64());\n      }\n\n      return a;\n    },\n    // Note: see getInt64() comment\n    getUint64: function getUint64() {\n      var low, high;\n\n      if (this.littleEndian) {\n        low = this.getUint32();\n        high = this.getUint32();\n      } else {\n        high = this.getUint32();\n        low = this.getUint32();\n      }\n\n      return high * 0x100000000 + low;\n    },\n    getFloat32: function getFloat32() {\n      var value = this.dv.getFloat32(this.offset, this.littleEndian);\n      this.offset += 4;\n      return value;\n    },\n    getFloat32Array: function getFloat32Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat32());\n      }\n\n      return a;\n    },\n    getFloat64: function getFloat64() {\n      var value = this.dv.getFloat64(this.offset, this.littleEndian);\n      this.offset += 8;\n      return value;\n    },\n    getFloat64Array: function getFloat64Array(size) {\n      var a = [];\n\n      for (var i = 0; i < size; i++) {\n        a.push(this.getFloat64());\n      }\n\n      return a;\n    },\n    getArrayBuffer: function getArrayBuffer(size) {\n      var value = this.dv.buffer.slice(this.offset, this.offset + size);\n      this.offset += size;\n      return value;\n    },\n    getString: function getString(size) {\n      var a = new Uint8Array(size);\n\n      for (var i = 0; i < size; i++) {\n        a[i] = this.getUint8();\n      }\n\n      var nullByte = a.indexOf(0);\n      if (nullByte >= 0) a = a.slice(0, nullByte);\n      return THREE.LoaderUtils.decodeText(a);\n    }\n  }); // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n  // and BinaryParser( FBX Binary format)\n\n  function FBXTree() {}\n\n  Object.assign(FBXTree.prototype, {\n    add: function add(key, val) {\n      this[key] = val;\n    }\n  });\n\n  function isFbxFormatBinary(buffer) {\n    var CORRECT = 'Kaydara FBX Binary  \\0';\n    return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n  }\n\n  function isFbxFormatASCII(text) {\n    var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n    var cursor = 0;\n\n    function read(offset) {\n      var result = text[offset - 1];\n      text = text.slice(cursor + offset);\n      cursor++;\n      return result;\n    }\n\n    for (var i = 0; i < CORRECT.length; ++i) {\n      var num = read(1);\n\n      if (num === CORRECT[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getFbxVersion(text) {\n    var versionRegExp = /FBXVersion: (\\d+)/;\n    var match = text.match(versionRegExp);\n\n    if (match) {\n      var version = parseInt(match[1]);\n      return version;\n    }\n\n    throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n  } // Converts FBX ticks into real time seconds.\n\n\n  function convertFBXTimeToSeconds(time) {\n    return time / 46186158000;\n  } // Parses comma separated list of numbers and returns them an array.\n  // Used internally by the TextParser\n\n\n  function parseNumberArray(value) {\n    var array = value.split(',').map(function (val) {\n      return parseFloat(val);\n    });\n    return array;\n  }\n\n  function convertArrayBufferToString(buffer, from, to) {\n    if (from === undefined) from = 0;\n    if (to === undefined) to = buffer.byteLength;\n    return THREE.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n  }\n\n  function append(a, b) {\n    for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n      a[j] = b[i];\n    }\n  }\n\n  function slice(a, b, from, to) {\n    for (var i = from, j = 0; i < to; i++, j++) {\n      a[j] = b[i];\n    }\n\n    return a;\n  } // inject array a2 into array a1 at index\n\n\n  function inject(a1, index, a2) {\n    return a1.slice(0, index).concat(a2).concat(a1.slice(index));\n  }\n})();\n\n//# sourceURL=webpack:///./js/vendor/FBXLoader.js?");

/***/ }),

/***/ "./js/vendor/inflate.module.min.js":
/*!*****************************************!*\
  !*** ./js/vendor/inflate.module.min.js ***!
  \*****************************************/
/*! exports provided: Zlib */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Zlib\", function() { return Zlib; });\n/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */\nvar mod = {},\n    l = void 0,\n    aa = mod;\n\nfunction r(c, d) {\n  var a = c.split(\".\"),\n      b = aa;\n  !(a[0] in b) && b.execScript && b.execScript(\"var \" + a[0]);\n\n  for (var e; a.length && (e = a.shift());) {\n    !a.length && d !== l ? b[e] = d : b = b[e] ? b[e] : b[e] = {};\n  }\n}\n\n;\nvar t = \"undefined\" !== typeof Uint8Array && \"undefined\" !== typeof Uint16Array && \"undefined\" !== typeof Uint32Array && \"undefined\" !== typeof DataView;\n\nfunction v(c) {\n  var d = c.length,\n      a = 0,\n      b = Number.POSITIVE_INFINITY,\n      e,\n      f,\n      g,\n      h,\n      k,\n      m,\n      n,\n      p,\n      s,\n      x;\n\n  for (p = 0; p < d; ++p) {\n    c[p] > a && (a = c[p]), c[p] < b && (b = c[p]);\n  }\n\n  e = 1 << a;\n  f = new (t ? Uint32Array : Array)(e);\n  g = 1;\n  h = 0;\n\n  for (k = 2; g <= a;) {\n    for (p = 0; p < d; ++p) {\n      if (c[p] === g) {\n        m = 0;\n        n = h;\n\n        for (s = 0; s < g; ++s) {\n          m = m << 1 | n & 1, n >>= 1;\n        }\n\n        x = g << 16 | p;\n\n        for (s = m; s < e; s += k) {\n          f[s] = x;\n        }\n\n        ++h;\n      }\n    }\n\n    ++g;\n    h <<= 1;\n    k <<= 1;\n  }\n\n  return [f, a, b];\n}\n\n;\n\nfunction w(c, d) {\n  this.g = [];\n  this.h = 32768;\n  this.d = this.f = this.a = this.l = 0;\n  this.input = t ? new Uint8Array(c) : c;\n  this.m = !1;\n  this.i = y;\n  this.r = !1;\n  if (d || !(d = {})) d.index && (this.a = d.index), d.bufferSize && (this.h = d.bufferSize), d.bufferType && (this.i = d.bufferType), d.resize && (this.r = d.resize);\n\n  switch (this.i) {\n    case A:\n      this.b = 32768;\n      this.c = new (t ? Uint8Array : Array)(32768 + this.h + 258);\n      break;\n\n    case y:\n      this.b = 0;\n      this.c = new (t ? Uint8Array : Array)(this.h);\n      this.e = this.z;\n      this.n = this.v;\n      this.j = this.w;\n      break;\n\n    default:\n      throw Error(\"invalid inflate mode\");\n  }\n}\n\nvar A = 0,\n    y = 1,\n    B = {\n  t: A,\n  s: y\n};\n\nw.prototype.k = function () {\n  for (; !this.m;) {\n    var c = C(this, 3);\n    c & 1 && (this.m = !0);\n    c >>>= 1;\n\n    switch (c) {\n      case 0:\n        var d = this.input,\n            a = this.a,\n            b = this.c,\n            e = this.b,\n            f = d.length,\n            g = l,\n            h = l,\n            k = b.length,\n            m = l;\n        this.d = this.f = 0;\n        if (a + 1 >= f) throw Error(\"invalid uncompressed block header: LEN\");\n        g = d[a++] | d[a++] << 8;\n        if (a + 1 >= f) throw Error(\"invalid uncompressed block header: NLEN\");\n        h = d[a++] | d[a++] << 8;\n        if (g === ~h) throw Error(\"invalid uncompressed block header: length verify\");\n        if (a + g > d.length) throw Error(\"input buffer is broken\");\n\n        switch (this.i) {\n          case A:\n            for (; e + g > b.length;) {\n              m = k - e;\n              g -= m;\n              if (t) b.set(d.subarray(a, a + m), e), e += m, a += m;else for (; m--;) {\n                b[e++] = d[a++];\n              }\n              this.b = e;\n              b = this.e();\n              e = this.b;\n            }\n\n            break;\n\n          case y:\n            for (; e + g > b.length;) {\n              b = this.e({\n                p: 2\n              });\n            }\n\n            break;\n\n          default:\n            throw Error(\"invalid inflate mode\");\n        }\n\n        if (t) b.set(d.subarray(a, a + g), e), e += g, a += g;else for (; g--;) {\n          b[e++] = d[a++];\n        }\n        this.a = a;\n        this.b = e;\n        this.c = b;\n        break;\n\n      case 1:\n        this.j(ba, ca);\n        break;\n\n      case 2:\n        for (var n = C(this, 5) + 257, p = C(this, 5) + 1, s = C(this, 4) + 4, x = new (t ? Uint8Array : Array)(D.length), S = l, T = l, U = l, u = l, M = l, F = l, z = l, q = l, V = l, q = 0; q < s; ++q) {\n          x[D[q]] = C(this, 3);\n        }\n\n        if (!t) {\n          q = s;\n\n          for (s = x.length; q < s; ++q) {\n            x[D[q]] = 0;\n          }\n        }\n\n        S = v(x);\n        u = new (t ? Uint8Array : Array)(n + p);\n        q = 0;\n\n        for (V = n + p; q < V;) {\n          switch (M = E(this, S), M) {\n            case 16:\n              for (z = 3 + C(this, 2); z--;) {\n                u[q++] = F;\n              }\n\n              break;\n\n            case 17:\n              for (z = 3 + C(this, 3); z--;) {\n                u[q++] = 0;\n              }\n\n              F = 0;\n              break;\n\n            case 18:\n              for (z = 11 + C(this, 7); z--;) {\n                u[q++] = 0;\n              }\n\n              F = 0;\n              break;\n\n            default:\n              F = u[q++] = M;\n          }\n        }\n\n        T = t ? v(u.subarray(0, n)) : v(u.slice(0, n));\n        U = t ? v(u.subarray(n)) : v(u.slice(n));\n        this.j(T, U);\n        break;\n\n      default:\n        throw Error(\"unknown BTYPE: \" + c);\n    }\n  }\n\n  return this.n();\n};\n\nvar G = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    D = t ? new Uint16Array(G) : G,\n    H = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258],\n    I = t ? new Uint16Array(H) : H,\n    J = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0],\n    K = t ? new Uint8Array(J) : J,\n    L = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],\n    da = t ? new Uint16Array(L) : L,\n    ea = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],\n    N = t ? new Uint8Array(ea) : ea,\n    O = new (t ? Uint8Array : Array)(288),\n    P,\n    fa;\nP = 0;\n\nfor (fa = O.length; P < fa; ++P) {\n  O[P] = 143 >= P ? 8 : 255 >= P ? 9 : 279 >= P ? 7 : 8;\n}\n\nvar ba = v(O),\n    Q = new (t ? Uint8Array : Array)(30),\n    R,\n    ga;\nR = 0;\n\nfor (ga = Q.length; R < ga; ++R) {\n  Q[R] = 5;\n}\n\nvar ca = v(Q);\n\nfunction C(c, d) {\n  for (var a = c.f, b = c.d, e = c.input, f = c.a, g = e.length, h; b < d;) {\n    if (f >= g) throw Error(\"input buffer is broken\");\n    a |= e[f++] << b;\n    b += 8;\n  }\n\n  h = a & (1 << d) - 1;\n  c.f = a >>> d;\n  c.d = b - d;\n  c.a = f;\n  return h;\n}\n\nfunction E(c, d) {\n  for (var a = c.f, b = c.d, e = c.input, f = c.a, g = e.length, h = d[0], k = d[1], m, n; b < k && !(f >= g);) {\n    a |= e[f++] << b, b += 8;\n  }\n\n  m = h[a & (1 << k) - 1];\n  n = m >>> 16;\n  if (n > b) throw Error(\"invalid code length: \" + n);\n  c.f = a >> n;\n  c.d = b - n;\n  c.a = f;\n  return m & 65535;\n}\n\nw.prototype.j = function (c, d) {\n  var a = this.c,\n      b = this.b;\n  this.o = c;\n\n  for (var e = a.length - 258, f, g, h, k; 256 !== (f = E(this, c));) {\n    if (256 > f) b >= e && (this.b = b, a = this.e(), b = this.b), a[b++] = f;else {\n      g = f - 257;\n      k = I[g];\n      0 < K[g] && (k += C(this, K[g]));\n      f = E(this, d);\n      h = da[f];\n      0 < N[f] && (h += C(this, N[f]));\n      b >= e && (this.b = b, a = this.e(), b = this.b);\n\n      for (; k--;) {\n        a[b] = a[b++ - h];\n      }\n    }\n  }\n\n  for (; 8 <= this.d;) {\n    this.d -= 8, this.a--;\n  }\n\n  this.b = b;\n};\n\nw.prototype.w = function (c, d) {\n  var a = this.c,\n      b = this.b;\n  this.o = c;\n\n  for (var e = a.length, f, g, h, k; 256 !== (f = E(this, c));) {\n    if (256 > f) b >= e && (a = this.e(), e = a.length), a[b++] = f;else {\n      g = f - 257;\n      k = I[g];\n      0 < K[g] && (k += C(this, K[g]));\n      f = E(this, d);\n      h = da[f];\n      0 < N[f] && (h += C(this, N[f]));\n      b + k > e && (a = this.e(), e = a.length);\n\n      for (; k--;) {\n        a[b] = a[b++ - h];\n      }\n    }\n  }\n\n  for (; 8 <= this.d;) {\n    this.d -= 8, this.a--;\n  }\n\n  this.b = b;\n};\n\nw.prototype.e = function () {\n  var c = new (t ? Uint8Array : Array)(this.b - 32768),\n      d = this.b - 32768,\n      a,\n      b,\n      e = this.c;\n  if (t) c.set(e.subarray(32768, c.length));else {\n    a = 0;\n\n    for (b = c.length; a < b; ++a) {\n      c[a] = e[a + 32768];\n    }\n  }\n  this.g.push(c);\n  this.l += c.length;\n  if (t) e.set(e.subarray(d, d + 32768));else for (a = 0; 32768 > a; ++a) {\n    e[a] = e[d + a];\n  }\n  this.b = 32768;\n  return e;\n};\n\nw.prototype.z = function (c) {\n  var d,\n      a = this.input.length / this.a + 1 | 0,\n      b,\n      e,\n      f,\n      g = this.input,\n      h = this.c;\n  c && (\"number\" === typeof c.p && (a = c.p), \"number\" === typeof c.u && (a += c.u));\n  2 > a ? (b = (g.length - this.a) / this.o[2], f = 258 * (b / 2) | 0, e = f < h.length ? h.length + f : h.length << 1) : e = h.length * a;\n  t ? (d = new Uint8Array(e), d.set(h)) : d = h;\n  return this.c = d;\n};\n\nw.prototype.n = function () {\n  var c = 0,\n      d = this.c,\n      a = this.g,\n      b,\n      e = new (t ? Uint8Array : Array)(this.l + (this.b - 32768)),\n      f,\n      g,\n      h,\n      k;\n  if (0 === a.length) return t ? this.c.subarray(32768, this.b) : this.c.slice(32768, this.b);\n  f = 0;\n\n  for (g = a.length; f < g; ++f) {\n    b = a[f];\n    h = 0;\n\n    for (k = b.length; h < k; ++h) {\n      e[c++] = b[h];\n    }\n  }\n\n  f = 32768;\n\n  for (g = this.b; f < g; ++f) {\n    e[c++] = d[f];\n  }\n\n  this.g = [];\n  return this.buffer = e;\n};\n\nw.prototype.v = function () {\n  var c,\n      d = this.b;\n  t ? this.r ? (c = new Uint8Array(d), c.set(this.c.subarray(0, d))) : c = this.c.subarray(0, d) : (this.c.length > d && (this.c.length = d), c = this.c);\n  return this.buffer = c;\n};\n\nfunction W(c, d) {\n  var a, b;\n  this.input = c;\n  this.a = 0;\n  if (d || !(d = {})) d.index && (this.a = d.index), d.verify && (this.A = d.verify);\n  a = c[this.a++];\n  b = c[this.a++];\n\n  switch (a & 15) {\n    case ha:\n      this.method = ha;\n      break;\n\n    default:\n      throw Error(\"unsupported compression method\");\n  }\n\n  if (0 !== ((a << 8) + b) % 31) throw Error(\"invalid fcheck flag:\" + ((a << 8) + b) % 31);\n  if (b & 32) throw Error(\"fdict flag is not supported\");\n  this.q = new w(c, {\n    index: this.a,\n    bufferSize: d.bufferSize,\n    bufferType: d.bufferType,\n    resize: d.resize\n  });\n}\n\nW.prototype.k = function () {\n  var c = this.input,\n      d,\n      a;\n  d = this.q.k();\n  this.a = this.q.a;\n\n  if (this.A) {\n    a = (c[this.a++] << 24 | c[this.a++] << 16 | c[this.a++] << 8 | c[this.a++]) >>> 0;\n    var b = d;\n\n    if (\"string\" === typeof b) {\n      var e = b.split(\"\"),\n          f,\n          g;\n      f = 0;\n\n      for (g = e.length; f < g; f++) {\n        e[f] = (e[f].charCodeAt(0) & 255) >>> 0;\n      }\n\n      b = e;\n    }\n\n    for (var h = 1, k = 0, m = b.length, n, p = 0; 0 < m;) {\n      n = 1024 < m ? 1024 : m;\n      m -= n;\n\n      do {\n        h += b[p++], k += h;\n      } while (--n);\n\n      h %= 65521;\n      k %= 65521;\n    }\n\n    if (a !== (k << 16 | h) >>> 0) throw Error(\"invalid adler-32 checksum\");\n  }\n\n  return d;\n};\n\nvar ha = 8;\nr(\"Zlib.Inflate\", W);\nr(\"Zlib.Inflate.prototype.decompress\", W.prototype.k);\nvar X = {\n  ADAPTIVE: B.s,\n  BLOCK: B.t\n},\n    Y,\n    Z,\n    $,\n    ia;\nif (Object.keys) Y = Object.keys(X);else for (Z in Y = [], $ = 0, X) {\n  Y[$++] = Z;\n}\n$ = 0;\n\nfor (ia = Y.length; $ < ia; ++$) {\n  Z = Y[$], r(\"Zlib.Inflate.BufferType.\" + Z, X[Z]);\n}\n\nvar Zlib = mod.Zlib;\n\n\n//# sourceURL=webpack:///./js/vendor/inflate.module.min.js?");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./js/app.js */\"./js/app.js\");\n\n\n//# sourceURL=webpack:///multi_./js/app.js?");

/***/ })

/******/ });